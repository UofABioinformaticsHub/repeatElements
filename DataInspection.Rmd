---
title: "Data Inspection"
author: "Steve Pederson"
date: "12/11/2015"
output: pdf_document
---

# Inspection of Data Before Re-Analysis

## Workspace Preparation
Before re-analysing the data a thorough inspection of the data structure needed to be undertaken.
This can shed light on the occurrence rates of TEs within each region, along with the co-occurrence rates within each region.

Firstly, the required *R* packages were loaded.
Amongst these is a custom package `funsForLu` hosted on GitHub & which contains some functions specific to this analysis.
To install this package, run the following code.

```{r funsForLu, eval=FALSE}
install.packages(devtools)
library(devtools)
install_github("steveped/funsForLu")
```

Some additional shortcuts are also included from the custom package `spShortcuts` which can be installed using the following.

```{r spShortcuts, eval=FALSE}
install_github("steveped/spShortcuts")
```

Now these can be loaded along with the other required packages for the analysis.

```{r loadPackages, message=FALSE}
library(ggplot2)
library(dplyr)
library(magrittr)
library(reshape2)
library(matrixStats)
library(VennDiagram)
library(knitr)
library(scales)
library(funsForLu)
library(spShortcuts)
```

Next the data was loaded whilst ignoring the FPKM data, and the various element types, along with the sampled genomic regions were identified

```{r loadData, cache=TRUE}
tpmFile <- file.path("data", "new_whole_gene_expression_dataset.txt")
tpmData <- read.delim(tpmFile, sep="\t", stringsAsFactors = FALSE) %>% 
  select(-contains("FPKM")) %>%
  tbl_df
```


```{r elTypes}
elTypes <- gsub("(.+)_.+_IDs", "\\1", 
                grep("IDs", colnames(tpmData), value = TRUE)) %>%
  unique %>%
  sort
```

```{r elRegs}
elRegs <- gsub(".+_(.+)_IDs", "\\1", 
                grep("IDs", colnames(tpmData), value = TRUE)) %>%
  unique %>%
  sort
```

## Data Overview by Region

A key feature of this dataset is that many genes contain multiple elements, with only a minority of genes containing a single TE.
The 5 elements being investigated in this analysis are `r paste(elTypes[-5], collapse=", ")` & `r elTypes[5]`.

The appearance of these elements is additionally annotated across 4 genomic regions in this dataset:  
1. *cds*:- elements in the coding sequence itself  
2. *prox*:- elements in the proximal promoter  
3. *utr3*:- elements in the 3' UTR of a transcript  
4. *utr5*:- elements in the 5' UTR of a transcript  

```{r longData, cache=TRUE, dependson='loadData'}
longData <- tpmData %>%
  melt(id.vars = 1, measure.vars = grep("IDs", colnames(tpmData), value = TRUE), 
       variable.name = "element", value.name = "Present") %>%
  mutate(Present = as.logical(Present),
         Element = gsub("(.+)_.+_IDs", "\\1", grep("IDs", element, value = TRUE)),
         Region = gsub(".+_(.+)_IDs", "\\1", grep("IDs", element, value = TRUE))) %>%
  select(-element) %>%
  tbl_df
```

The counts of these elements was then assessed across each region, with TEs being far less frequent in coding sequences, whilst 5' UTRs showed the most enrichment.
```{r plotRegionCounts, fig.width=7, fig.height=5, fig.cap='The number of appearances for each TE within each region.'}
longData %>%
  filter(Present) %>%
  ggplot(aes(x = Element, fill=Element)) +
  geom_bar() +
  facet_wrap(~Region, scales = "free_y")
```

The overall appearances of any element within each region were also assessed, as seen in the following Venn Diagram
```{r regionVenn, results='hide', fig.cap='Distributions of TEs within annotated regions'}
regElements <- sapply(elRegs, 
                      function(x){select(tpmData, contains(x)) %>% rowSums %>% as.logical},
                      simplify = FALSE) %>%
  as.data.frame %>%
  mutate(ID = tpmData$ID) %>%
  select(ID, one_of(elRegs)) %>%
  tbl_df
regVennCounts <- getVennCounts(regElements[,-1])
regUniCount <- paste("No elements:", sum(rowSums(regElements[-1]) ==0))
vennCols <- c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3")
grid.newpage()
do.call(draw.quad.venn, c(regVennCounts, list(fill = vennCols[-5])))
grid.text(regUniCount, 0.2, .1 )
```

Given the total number of genes under consideration (n = `r nrow(tpmData)`), the breakdown of how many genes contained an element in a given region is also given below:
```{r regTable, echo=FALSE, include=TRUE, results='asis'}
sapply(c("sum", "mean"), function(x){summarise_each(regElements, funs_(x), one_of(elRegs))}, simplify = FALSE) %>% 
  lapply(t) %>% 
  as.data.frame %>% 
  add_rownames(var="Region") %>% 
  rename(Total = sum, Proportion = mean) %>% 
  bind_rows(data_frame(Region ="none", 
                       Total = filter(regElements, !cds, !prox, !utr3, !utr5) %>% nrow(), 
                       Proportion = Total / nrow(tpmData))) %>%
  kable(digits = c(0, 0, 4), caption = "The counts & proportions of genes with TEs across each annotated region.")
```

## Undetectable genes across all tissues

```{r addTECols}
tpmData %<>% 
  mutate(TE = as.logical(rowSums(as.matrix(regElements[,-1]))),
         maxExp = rowMaxs(as.matrix(select(tpmData, contains("TPM")))))
```

It was also noted that `r sum(tpmData$maxExp == -Inf)` genes were not detectable in any tissue, these were left in the dataset for any analysis involving gene length and probability of containing a TE.
However, for any analysis involving expression levels, these were removed as they contained no relevant information for these analyses.
The overall number of these with TEs is given below.
Expressed genes with at last one TE clearly make up the majority of this dataset.

```{r expCounts}
expCounts <- tpmData %>% 
  mutate(Expressed = maxExp > -Inf) %>% 
  count_(c("Expressed", "TE"))
```

```{r detectVsTeE, echo=FALSE}
expCounts %>% 
  rename(`Contains TE`=TE,
         Total = n) %>% 
  kable
```

A`fisher.test` was performed on the above table, and genes with a TE were found as more likely to be in the expressed set of genes (p = `r format(fisher.test(matrix(expCounts$n, nrow=2))$p.value, digits = 3) `).


## Gene Lengths for Genes With One or No TEs
```{r regLengths}
noElements <- filter(regElements, !cds, !prox, !utr3, !utr5) %>% select(ID)
cdsOnly <- filter(regElements, cds, !prox, !utr3, !utr5) %>% select(ID)
proxOnly <- filter(regElements, !cds, prox, !utr3, !utr5) %>% select(ID)
utr3Only <- filter(regElements, !cds, !prox, utr3, !utr5) %>% select(ID)
utr5Only <- filter(regElements, !cds, prox, !utr3, !utr5) %>% select(ID)
multiple <- mutate(regElements, nReg = cds + prox + utr3 + utr5) %>% 
  filter(nReg > 1) %>% 
  select(ID)
regLengths <- list(noTE = noElements, 
                   cdsOnly=cdsOnly, proxOnly=proxOnly, utr3Only=utr3Only, utr5Only=utr5Only, 
                   multipleRegions = multiple) %>%
  sapply(function(x){filter(tpmData, ID %in% x$ID)$length}, simplify = FALSE) %>%
  lapply(log)
```

When inspecting the relationship between gene length and the region a TE is found in, it was noticed that only genes with TEs in the CDS or 3'UTR showed a bias towards longer length, whilst for proximal promoters & 5'UTRs there was a bias towards shorter genes.

```{r boxplotLengths, echo=FALSE, fig.cap='Gene lengths for genes with a single, or no TE.'}
lapply(names(regLengths), function(x){data_frame(Region = x,
                                                 Length = regLengths[[x]])}) %>%
  bind_rows %>%
  mutate(Region = factor(Region, levels=names(regLengths))) %>%
  ggplot(aes(x = Region, y = Length, fill = Region)) +
  geom_boxplot() +
  theme_bw() +
  guides(fill = FALSE) +
  labs(x = "Region with TE", y = "log(Gene Length)")
```

A Wilcoxon Test was performed on each set of genes lengths associated with the region in which a TE is found.
Most notably, only genes with TEs in the 3'UTR, or in multiple regions seemed associated with any increase in gene length.

```{r lengthWilcox}
lengthWilcox <- apply(combn(names(regLengths), 2),
                      2, 
                      function(x){wilcox.test(regLengths[[x[1]]], regLengths[[x[2]]])})
names(lengthWilcox) <- apply(combn(names(regLengths),2), 2, paste0, collapse=" Vs ")
```

```{r lengthWilcoxTab, echo=FALSE}
sapply(lengthWilcox, function(x){x$p.value}) %>% 
  as.data.frame() %>% 
  add_rownames("Comparison") %>% 
  select(Comparison, p = 2) %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         sig  = aster(adjP)) %>%
  kable(format.args = list(scientific=TRUE, digits=3),
        col.names = c("Comparison", "p-value", "adjusted p-value", ""))
```


Further inspecting the relationship between the number of regions containing a TE and gene length, showed that on average there was minimal difference in gene lengths between genes with 1 or 0 TEs, with the expected increasing length only evident for genes with TEs in 2 or more regions.

```{r plotNRegVLength, fig.cap='The relationship between the number of regions containing a TE and gene length', echo=FALSE}
bind_cols(tpmData, regElements[,-1]) %>% 
  mutate(nReg = as.factor(cds + prox + utr3 + utr5)) %>%
  ggplot(aes(x = nReg, y = log(length), fill = nReg)) +
  geom_boxplot() +
  guides(fill = FALSE) +
  theme_bw() +
  labs(x = "Number of Regions Containing a TE", y = "log(Gene Length)")
```

```{r tabNRegVLength, echo=FALSE, results='asis'}
bind_cols(tpmData, regElements[,-1]) %>% 
  mutate(nReg = as.factor(cds + prox + utr3 + utr5)) %>% 
  group_by(nReg) %>% 
  summarise(mn = mean(log(length)),Total = n()) %>%
  rename(`Number of Regions Containing a TE` = nReg,
         `Mean log(Gene Length)` = mn,
         `Number of Genes` = Total) %>%
  kable
```

# Analytic Approach
In order to combat the confounding of predictor variables a *tilted* bootstrapping approach was decided on.
Under this approach, genes can be binned based on a variable such as length, or the presence/absence of any combination of TEs.
Considering the data to be a test set of genes and a reference set of genes, the distribution of genes within these bins can be used to sample genes from the reference set so as to resemble the test set of genes, i.e. using a tilted bootstrap where the probability of sampling a gene is based on the probability of appearance for "like" genes in the test set of genes.

By way of example, for the test dataset we may be interested in the effects of an *alu* element. 
The probability of observing an L1 in an exclusive pair with at *alu* element would then be used to sample genes with only an L1 element from the reference dataset.
When repeated for all combinations of elements found with an *alu* element, the reference dataset will then resemble the test dataset, with the difference that all sampled genes in the test dataset would contain an *alu* element. 

For each bootstrap iteration, the median TPM value for the sampled reference set of genes can be subtracted from the median TPM values for the sampled test set of genes.
This allows for the continued incorporation of genes with log(TP) of -$\infty$ and the non-normal distribution that will result.
This is also an appropriate choice of strategy for count data, as is at the heart of the TPM values. 

After a suitable number of bootstrap iterations (e.g. 1000) a sampled density of the difference in median TPM values will be obtained for each tissue, and the probability of observing values > 0 can be simply estimated.  

A function to perform the bootstrap procedure (`bootMedians`) has been written and included in the minimal package `funsForLu` with installation instructions given above.

This process & some results are shown in the following sections which assess the effects of having one or more TEs in a specific region associated with a gene/transcript.

## The overall presence of a TE within a single region
At this early & broad stage of the analysis, the test set of genes would be the set of genes shown in the above Venn Diagram, which only contain TEs within a single region, thus avoiding any potential confounding due to presence of TEs within multiple regions.
The sample size for this appears to be more than adequate given the above Venn Diagram too.
The number &/or type of TEs in the region are not considered.
These genes are compared to those genes with no TEs in any region as the reference set of genes.
These lists were all created above. 

```{r allSingle}
allSingle <- bind_rows(cdsOnly, proxOnly, utr3Only, utr5Only)
```

The main confounding factor for this analysis would be gene length, as a Wilcoxon Test on the length of the genes within each group revealed this to be statistically significant (p = `r scientific(wilcox.test(regLengths$noTE, unlist(regLengths[2:6]))$p.value)`), with genes containing a single TE tending to be longer than genes without.

```{r teVsNoTELength, echo=FALSE, fig.height=5, fig.width=7, fig.cap='Length densities for genes with no TE Vs those with a single TE.'}
bind_rows(data_frame(TE ="No TE", length= regLengths$noTE), 
          data_frame(TE = "Single TE", length= unlist(regLengths[2:6]))) %>% 
  ggplot(aes(x= length, fill = TE)) + 
  geom_density(alpha=0.5) +
  theme_bw() +
  guides(fill = guide_legend(override.aes = list(colour = NULL))) +
  theme(legend.key = element_rect(colour = "black")) +
  labs(x = "log(Gene Length)", y = "Density")
```

Thus genes can be placed into a number of approximately equally-sized bins based the overall length distribution.

```{r nBins}
nBins <- 10
lengthBins <- quantile(tpmData$length, probs = seq(0, 1, length.out = nBins + 1))
tpmData %<>% 
  mutate(lengthBin = findInterval(length, lengthBins, rightmost.closed=TRUE))
```

`r nBins` bins based on length were chosen, and these are shown in the following histogram.
This information was added as an additional column to the object `tpmData`

```{r lengthBins, echo = FALSE, fig.cap='Bins based on gene length, using the length of genes across the entire dataset'}
ggplot(tpmData, aes(x = log(length))) +
  geom_histogram(binwidth = 0.1, colour = "black", fill="grey50", alpha=0.8) +
  theme_bw() +
  labs(x = "log(Length)", y = "Count") +
  geom_vline(x = log(lengthBins), col="blue", alpha=0.5, linetype=2)
```

The distributions from each dataset within each bin are first setup, leading to the sampling probabilities for the reference dataset.

```{r tiltSetup}
testData <- tpmData %>% 
  filter(ID %in% bind_rows(cdsOnly, proxOnly, utr3Only, utr5Only)[[1]]) 
testBins <- testData %>% 
  group_by(lengthBin) %>% 
  tally %>%
  mutate(p = n / sum(n))
refData <- tpmData %>% 
  filter(ID %in% noElements[[1]]) 
refBins <- refData %>% 
  group_by(lengthBin) %>% 
  tally %>%
  mutate(p = n / sum(n),
         effP = testBins$p / n) 
w <- refBins$effP[match(refData$lengthBin, refBins$lengthBin)]
```

The probabilities of bin membership are shown for each dataset.
```{r lengthBinProbs, echo=FALSE}
bind_rows(data_frame(TE ="No TE", bin = factor(refBins$lengthBin), p = refBins$p),
          data_frame(TE = "Single TE", bin = factor(testBins$lengthBin), p = testBins$p)) %>%
  ggplot(aes(x = bin, y = p, fill = TE))+
  geom_bar(stat="identity", position="dodge")
```

And after sampling,the length densities for 6 bootstrapped samples from each set of genes can be seen below, with the two length distributions clearly being much closer than before the sampling weights (i.e. the tilting) were applied.

```{r testSamp, message=FALSE, warning=FALSE}
set.seed(39990)
testSamp <- list(test = replicate(6, sample_n(testData,1000, TRUE)$length),
                 ref = replicate(6, sample_n(refData, 1000, TRUE, w)$length))
colnames(testSamp$test) <- colnames(testSamp$ref) <- paste0("Replicate", 1:6)
lapply(c("test", "ref"), function(x){data.frame(dataset = x, length = testSamp[[x]])}) %>%
  bind_rows %>%
  melt(id.vars = "dataset", variable.name = "Replicate", value.name= "length") %>%
  mutate(Replicate = gsub("length.", "", Replicate)) %>%
  ggplot(aes(x = log(length), fill = dataset))+
  geom_density(alpha = 0.5) +
  facet_wrap(~Replicate) +
    theme_bw() +
  guides(fill = guide_legend(override.aes = list(colour = NULL))) +
  theme(legend.key = element_rect(colour = "black")) +
  labs(x = "log(Gene Length)", y = "Density")
```

Confirming the effectiveness of this process, a Wilcoxon Test on the length distributions from combined set of replicates (n=6000), yielded a p-value of `r format(wilcox.test(as.vector(testSamp$test), as.vector(testSamp$ref))$p.value, digits=4)`


Now all the correct data structures have been generated & the method demonstrated to be effective, the bootstrapping procedure can be simply performed by the following line of code.
Also note that genes which were undetectable in any tissue were removed for this analysis.
```{r allSingleBoot, cache=TRUE}
set.seed(34990)
allSingleBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                             allSingle$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 1000, nBoot = 1000 )
```

Surprisingly, the probabilities of seeing an increased median TPM were all very high.
```{r allSingleTab, echo=FALSE}
data.frame(P = allSingleBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  kable(col.names = c("Tissue", "P (Diff in Median Values > 0)"))
```

The densities, representing the difference in median TPM for the test genes (TE in a single region) vs median TPM for the reference genes (no TE), were all clearly to the right of zero.
The implication from this is that the presence of a TE in a single region leads to an increase in gene expression.

```{r allSinglePlot, echo=FALSE, message=FALSE}
allSingleBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

This was surprising, as a longer gene length is generally associated with a lower TPM values, and genes containing a single TE were observed to be longer that those without.
The raw data was also inspected and the median values for each tissue checked based on the presence of a TE in a single region.
The results from the bootstrap method seemed to be consistent with the raw data.
```{r allMeds}
tpmData %>% 
  filter(ID %in% c(allSingle$ID, noElements$ID),
         maxExp > -Inf) %>% 
  group_by(TE) %>% 
  summarise_each(funs(median), contains("TPM")) %>%
  kable
```


## CDS Regions Only

Instead of looking at the presence in any region, genes with a TE on the CDS only were compared to the reference set of genes.
As this was a far smaller dataset (n = `r nrow(cdsOnly)`), genes were bootstrapped in sets of 150.
```{r cdsOnlyBoot, cache=TRUE}
cdsOnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           cdsOnly$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 150, nBoot = 1000, minGenes=150)
```

These results were far more consistent with expectations, with Brain & Kidney Tissue showing the strongest effects.
```{r cdsOnlyTab, echo=FALSE}
data.frame(P = cdsOnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```


```{r cdsOnlyPlot, echo=FALSE, message=FALSE, warning=FALSE}
cdsOnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

Of note in these results were those for Skeletal Tissue, where the density appeared peculiar.
The median TPM for the test set of genes in this Tissue was `-Inf`, hence many of the bootstrap iterations would have a median difference of `-Inf`.

## Proximal Promoters

Next, the set of genes with a TE in the proximal promoter only were compared to the reference set of genes.
As this was a far larger dataset (n = `r nrow(proxOnly)`), genes were bootstrapped in sets of 1000.
```{r proxOnlyBoot, cache=TRUE}
proxOnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                            proxOnly$ID, noElements$ID, 
                            idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                            nGenes = 1000, nBoot = 1000)
```

The results for this region were again surprising, in that all tissues showed a strong tendency to higher gene expression if a TE was only present in the proximal promoter.

```{r proxOnlyTab, echo=FALSE}
data.frame(P = proxOnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r proxOnlyPlot, echo=FALSE, message=FALSE}
proxOnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## 3' UTRs

Next, the set of genes with a TE in the 3'UTR only were compared to the reference set of genes.
As this was a relatively large dataset (n = `r nrow(utr3Only)`), genes were again bootstrapped in sets of 1000.
```{r utr3OnlyBoot, cache=TRUE}
utr3OnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                            utr3Only$ID, noElements$ID, 
                            idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                            nGenes = 1000, nBoot = 1000)
```

The results for this region were again surprising, in that a clear repression of gene expression was observed in Testes & Brain, and to a lesser extent in Adipose Tissue & Skeletal Muscle.
In Kidney and Liver however, no clear pattern was observed.

```{r utr3OnlyTab, echo=FALSE}
data.frame(P = utr3OnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r utr3OnlyPlot, echo=FALSE, message=FALSE}
utr3OnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## 5' UTRs

Next, the set of genes with a TE in the 5'UTR only were compared to the reference set of genes.
As this was a relatively large dataset (n = `r nrow(utr5Only)`), genes were again bootstrapped in sets of 1000.
```{r utr5OnlyBoot, cache=TRUE}
utr5OnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                            utr5Only$ID, noElements$ID, 
                            idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                            nGenes = 1000, nBoot = 1000)
```

Again all tissues showed a clear increase in expression with the presence of a TE in the 5'UTR only.

```{r utr5OnlyTab, echo=FALSE}
data.frame(P = utr5OnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r utr5OnlyPlot, echo=FALSE, message=FALSE}
utr5OnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

Clearly the location of the TE has an effect on gene expression, but this may be strongly connected to the types of elements most commonly seen by themselves in each region (perhaps these were primarily *alu* elements).
It should also be noted that only `r length(regLengths$cdsOnly)` genes were sampled for the CDS region, so this may be a highly unrepresentative sample.

The tissue specific effects connected to the location of a single TE were also notable.

## TEs in multiple regions
```{r multRegs}
multRegs <- regElements %>%
  mutate(nReg = cds + prox + utr3 + utr5) %>%
  filter(nReg > 1) %>%
  select(ID)
```

As a result of the surprising observations above, the effects of TEs in multiple regions were also investigated.
Again, this was a large set of genes (n = `r nrow(multRegs)`).

```{r multRegsBoot, cache=TRUE}
multRegsBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                            multRegs$ID, noElements$ID, 
                            idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                            nGenes = 1000, nBoot = 1000)
```

No specific patterns were observable, with the exception of Brain, which showed a tendency towards reduced expression in the presence of elements in multiple genomic regions.

```{r multRegsTab, echo=FALSE}
data.frame(P = multRegsBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r multRegsPlot, echo=FALSE, message=FALSE}
multRegsBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

# Analysis by element type

The same approach was then taken looking the elements alone, regardless of the genomic region in which it was found.
```{r elementVenn, results='hide'}
typeElements <- sapply(elTypes, 
                      function(x){select(tpmData, contains(x)) %>% rowSums %>% as.logical},
                      simplify = FALSE) %>%
  as.data.frame %>%
  mutate(ID = tpmData$ID) %>%
  select(ID, one_of(elTypes)) %>%
  tbl_df
typeVennCounts <- getVennCounts(typeElements[,-1])
typeUniCount <- paste("No elements:", sum(rowSums(typeElements[-1]) ==0))
grid.newpage()
do.call(draw.quintuple.venn, c(typeVennCounts, list(fill = vennCols)))
grid.text(typeUniCount, 0.15, .8 )
```

As seen in the Venn Diagram above, the numbers of genes with L1 & LTR elements in isolation may be too small to make any strong claims.
However, the effects of each element acting in isolation was first investigated.

```{r, sepElements}
aluOnly <- filter(typeElements, alu, !L1, !L2, !LTR, !mir) %>%
  select(ID)
l1Only <- filter(typeElements, !alu, L1, !L2, !LTR, !mir) %>%
  select(ID)
l2Only <- filter(typeElements, !alu, !L1, L2, !LTR, !mir) %>%
  select(ID)
ltrOnly <- filter(typeElements, !alu, !L1, !L2, LTR, !mir) %>%
  select(ID)
mirOnly <- filter(typeElements, !alu, !L1, !L2, !LTR, mir) %>%
  select(ID)
multipleElements <- mutate(typeElements, nEl = alu + L1 + L2 + LTR + mir) %>%
  filter(nEl > 1) %>%
  select(ID)
```

## alu Elements

The total number of *alu* elements found in isolation is `r nrow(aluOnly)` perhaps lending a high degree of credibility to these particular results.
However, in reality this initial exploration only covers `r percent(nrow(aluOnly) / sum(typeElements$alu))` of genes with an *alu* element. 
Genes with an *alu* element alone were compared to genes with no TEs, using gene lengths as the binning parameter.

```{r aluOnlyBoot, cache=TRUE}
aluOnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           aluOnly$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 1000, nBoot = 1000)
```

Genes appear to demonstrate a higher level of expression across all tissues in this comparison, with the exception of Brain.
```{r aluOnlyTab, echo=FALSE}
data.frame(P = aluOnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r aluOnlyPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluOnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## L1 Elements

The total number of *L1* elements found in isolation is `r nrow(l1Only)`, which is much lower than *alu* elements, which only represents `r percent(nrow(l1Only) / sum(typeElements$L1))` of genes with an L1 element.
Genes with an *L1* element alone were compared to genes with no TEs, using gene lengths as the binning parameter.
Due to the relatively low number of elements, genes were bootstrapped in sets of 500.

```{r l1OnlyBoot, cache=TRUE}
l1OnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           l1Only$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 500, nBoot = 1000)
```

Contrary to *alu* elements, L1 elements generally appear to exert a repressive influence on gene expression when acting in isolation, with the most convincing results in Adipose Tissue, Brain & Testes.
```{r l1OnlyTab, echo=FALSE}
data.frame(P = l1OnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r l1OnlyPlot, echo=FALSE, message=FALSE, warning=FALSE}
l1OnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```


## L2 Elements

The total number of *L2* elements found in isolation is `r nrow(l2Only)` which is comparable to L1 elements, and as such these only represent `r percent(nrow(l2Only) / sum(typeElements$L2))` of genes with an L2 element.
Genes with an *L2* element alone were compared to genes with no TEs, using gene lengths as the binning parameter.

```{r l2OnlyBoot, cache=TRUE}
l2OnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           l2Only$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 1000, nBoot = 1000)
```

Contrary to L1 elements, L2 elements appear to increase gene expression when acting in isolation, although this appeared to be more of a bias than a statistically robust finding.
```{r l2OnlyTab, echo=FALSE}
data.frame(P = l2OnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r l2OnlyPlot, echo=FALSE, message=FALSE, warning=FALSE}
l2OnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```


## LTR Elements

The total number of LTR elements found in isolation is `r nrow(ltrOnly)`, which is the lowest of all elements and which only represents `r percent(nrow(ltrOnly) / sum(typeElements$LTR))` of genes with an LTR element.
Genes with an *LTR* element alone were compared to genes with no TEs, using gene lengths as the binning parameter.
Due to the relatively low number of elements, genes were bootstrapped in sets of 500.

```{r ltrOnlyBoot, cache=TRUE}
ltrOnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           ltrOnly$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 500, nBoot = 1000)
```

Contrary to *alu* & L2 elements, LTR elements appear to exert a repressive influence on gene expression when acting in isolation.
```{r ltrOnlyTab, echo=FALSE}
data.frame(P = ltrOnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r ltrOnlyPlot, echo=FALSE, message=FALSE, warning=FALSE}
ltrOnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```


## mir Elements

The total number of *mir* elements found in isolation is `r nrow(mirOnly)`, which only represents `r percent(nrow(mirOnly) / sum(typeElements$mir))` of genes with a mir element.
Genes with a *mir* element alone were compared to genes with no TEs, using gene lengths as the binning parameter.

```{r mirOnlyBoot, cache=TRUE}
mirOnlyBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           mirOnly$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 500, nBoot = 1000)
```

Contrary to the other element, *mir* elements in isolation appear to have no effect on gene expression.
```{r mirOnlyTab, echo=FALSE}
data.frame(P = mirOnlyBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r mirOnlyPlot, echo=FALSE, message=FALSE, warning=FALSE}
mirOnlyBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## Multiple Elements

The total number genes with multiple elements `r nrow(multipleElements)`, and these were also tested using length as the binning parameter.

```{r multipleBoot, cache=TRUE}
multipleBoot <- bootMedians(filter(tpmData, maxExp > -Inf), 
                           multipleElements$ID, noElements$ID, 
                             idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                             nGenes = 1000, nBoot = 1000)
```

The results from this strategy seemed divers, but no compelling conclusions could be drawn.

```{r multipleTab, echo=FALSE}
data.frame(P = multipleBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r multiplePlot, echo=FALSE, message=FALSE, warning=FALSE}
multipleBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```


## Gene lengths and Element Types
The connection between the presence of each type of element and gene length were also explored.

```{r elLengths}
elLengths <- list(none = noElements, 
                  aluOnly=aluOnly, L1Only=l1Only, L2Only=l2Only, 
                  LTROnly=ltrOnly, mirOnly=mirOnly, multiple = multipleElements) %>%
  sapply(function(x){filter(tpmData, ID %in% x$ID)$length}, simplify = FALSE) %>%
  lapply(log)
lapply(names(elLengths), function(x){data_frame(Element = x,
                                                 Length = elLengths[[x]])}) %>%
  bind_rows %>%
  mutate(Element = factor(Element, levels = names(elLengths))) %>%
  ggplot(aes(x = Element, y = Length, fill = Element)) +
  geom_boxplot() +
  theme_bw() +
  guides(fill = FALSE) +
  labs(x = "Element Type", y = "log(Gene Length)")
```

```{r lengthWilcoxEl}
lengthWilcoxEl <- apply(combn(names(elLengths), 2),
                      2, 
                      function(x){wilcox.test(elLengths[[x[1]]], elLengths[[x[2]]])})
names(lengthWilcoxEl) <- apply(combn(names(elLengths),2), 2, paste0, collapse=" Vs ")
```

```{r lengthWilcoxElTab}
sapply(lengthWilcoxEl, function(x){x$p.value}) %>% 
  as.data.frame() %>% 
  add_rownames("Comparison") %>% 
  select(Comparison, p = 2) %>%
  mutate(adjP = p.adjust(p, "bonferroni"),
         sig  = aster(adjP)) %>%
  kable(format.args = list(scientific=TRUE, digits=3),
        col.names = c("Comparison", "p-value", "adjusted p-value", ""))
```


Clearly the length distributions of genes with one *alu*, L2 or mir element alone are very similar to when no element is present, whilst other combinations of elements showed some variation in their association with gene length.

The number of elements found in a gene was also explored visually.
```{r nbrElVsLenPlot}
tpmData %>% 
  mutate(nEl = as.factor(mutate(typeElements, nEl = alu + L1 + L2 + LTR + mir)$nEl)) %>%
  ggplot(aes(x = nEl, y = log(length), fill = nEl)) +
  geom_boxplot() +
  theme_bw() +
  guides(fill = FALSE) +
  labs(x = "Number of elements in a gene", y= "log(Gene Length)")
```

# Comparison of genes with mir elements against those without
As the presence of a mir element in isolation appears to have no correlation with gene length, in order to investigate the effects of the presence of a mir element, an alternative binning strategy was used.
In this case, bins were determine based on the presence of all other elements in combination.
```{r mirData}
mirData <- tpmData %>% 
  mutate(mir = typeElements$mir, 
         other = binsFromCols(select(typeElements, -one_of("ID", "mir")))) %>%
  filter(maxExp > -Inf)
```

Thus the test set of genes would be the set of genes with a mir element, with sampling probabilities derived from the combinations of elements co-occurring with mir elements.
These sampling probabilities can then be used to sample the reference set of genes, which are those without a mir element.
As this dataset stands, however, mir elements co-occurring with all four elements represents nearly 30% of the annotated mir elements.
In the set of genes with no mir element, genes with the other four elements represent less than 2% of the total genes.
The tilting strategy outlined above would ensure that these elements are sampled multiple times in most iterations and the results may be biased by this phenomenon.
Removing this confounding group may be the best strategy to deal with this problem.
```{r mirBoot}
mirBoot <- bootMedians(filter(mirData, other!="alu_L1_L2_LTR"),
                       filter(mirData, mir)$ID, filter(mirData, !mir)$ID, 
                       binCol = "other$", valCols = "TPM", nGenes = 1000, nBoot = 1000)
```

Only in the Testes did any effects of mir elements appear plausible.
As such, the presence of mir elements could possibly be disregarded for the remainder of the analysis

```{r mirBootTab, echo=FALSE}
data.frame(P = mirBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r mirBootPlot, echo=FALSE, message=FALSE, warning=FALSE}
mirBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(x = expression(paste(Delta, "TPM")),y = "Density")
```

# Re-analysis Treating mir Elements as a non-TE
The Venn diagram for co-occurrence of elements was then redrawn with mir elements being disregarded.
```{r noMirVenn, results='hide'}
noMirVennCounts <- getVennCounts(select(typeElements, -ID, -mir))
noMirUniCount <- paste("No elements:", sum(rowSums(select(typeElements, -ID, -mir)) ==0))
grid.newpage()
do.call(draw.quad.venn, c(noMirVennCounts, list(fill = vennCols[-1])))
grid.text(noMirUniCount, 0.2, .1 )
```

## alu Elements

The elements co-occurring with an *alu* element were also investigated.
```{r aluCoPlot, fig.height =4, fig.width=4, results='hide', fig.cap="Elements co-occurring with an alu element"}
aluVennCounts <- typeElements %>% 
  filter(alu) %>%
  dplyr::select(-ID, -alu) %>% 
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(aluVennCounts, list(fill = vennCols[-5])))
```

The elements co-occurring where no *alu* elements is present were also investigated.
```{r noaluCoPlot, fig.height =4, fig.width=4, results='hide', fig.cap="Elements co-occurring where no alu element is present"}
aluVennCounts <- typeElements %>% 
  filter(!alu) %>%
  dplyr::select(-ID, -alu) %>% 
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(aluVennCounts, list(fill = vennCols[-5])))
```



```{r aluNoMirBoot, cache=TRUE}
aluData <- tpmData %>% 
  mutate(alu = typeElements$alu, 
         other = binsFromCols(select(typeElements, -one_of("ID", "alu", "mir")))) %>%
  filter(maxExp > -Inf)
testIDs <- filter(typeElements, alu, !L1, !L2, !LTR)$ID
refIDs <- filter(typeElements, !alu, !L1, !L2, !LTR)$ID
aluNoMirBoot <- bootMedians(aluData, 
                            testIDs, refIDs,
                            idCol = "ID$", binCol = "Bin$", valCols = "TPM", 
                            nGenes = 1000, nBoot = 1000)
```

Once again genes with *alu* elements in isolation were compared against the genes with no elements, but disregarding the presence of any mir elements, and using the length as the tilting variable.
This now represented `r length(testIDs)` genes, which was `r percent(length(testIDs) / sum(typeElements$alu))` of all *alu* elements.
Again, most genes appear to demonstrate a higher level of expression across all tissues, with the possible exception of the brain.
```{r aluNoMirTab, echo=FALSE}
data.frame(P = aluNoMirBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 4)
```

```{r aluNoMirPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluNoMirBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

In order to include all *alu* elements, the strategy of binning based on the combinations of co-occurring units was applied to the data, instead of binning based on length. 
It was also noted that the probabilities of an *alu* occurring alongside 3 or more elements, were vastly difference to the groups of three elements appearing with no *alu* elements, so these combinations were removed from the dataset. 

```{r aluData}
aluData <- tpmData %>% 
  select(-contains("IDs")) %>%
  mutate(alu = typeElements$alu, 
         other = binsFromCols(select(typeElements, -one_of("ID", "alu")))) %>%
  filter(maxExp > -Inf,
         !grepl(".+_.+_.+_.+",other))
```


```{r aluBoot, cache=TRUE}
aluBoot <- bootMedians(aluData, 
                       filter(aluData, alu)$ID, filter(aluData, !alu)$ID, 
                       binCol = "other$", valCols = "TPM", nGenes = 1000, nBoot = 1000)
```


```{r aluBootTab, echo=FALSE}
data.frame(P = aluBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r aluBootPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## L2 Elements


```{r l2Data}
l2Data <- tpmData %>% 
  select(-contains("IDs")) %>%
  mutate(l2 = typeElements$L2, 
         other = binsFromCols(select(typeElements, -one_of("ID", "L2")))) %>%
  filter(maxExp > -Inf,
         !grepl(".+_.+_.+_.+",other))
```

```{r l2CoPlot, fig.height =4, fig.width=4, results='hide', fig.cap="Elements co-occurring where no alu element is present"}
l2VennCounts <- typeElements %>% 
  filter(L2) %>%
  select(-ID, -L2) %>% 
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(l2VennCounts, list(fill = vennCols[-5])))
```



```{r nol2CoPlot, fig.height =4, fig.width=4, results='hide', fig.cap="Elements co-occurring where no alu element is present"}
l2VennCounts <- typeElements %>% 
  filter(!L2) %>%
  select(-ID, -L2) %>% 
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(l2VennCounts, list(fill = vennCols[-5])))
```


```{r l2Boot, cache=TRUE}
l2Boot <- bootMedians(l2Data, 
                       filter(l2Data, l2)$ID, filter(l2Data, !l2)$ID, 
                       binCol = "other$", valCols = "TPM", nGenes = 1000, nBoot = 1000)
```


```{r l2BootTab, echo=FALSE}
data.frame(P = l2Boot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r l2BootPlot, echo=FALSE, message=FALSE, warning=FALSE}
l2Boot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## L1 Elements


```{r l1Data}
l1Data <- tpmData %>% 
  dplyr::select(-contains("IDs")) %>%
  mutate(l1 = typeElements$L1, 
         other = binsFromCols(dplyr::select(typeElements, -one_of("ID", "L1")))) %>%
  filter(maxExp > -Inf,
         !grepl(".+_.+_.+_.+",other))
```

```{r l1CoPlot, fig.height =4, fig.width=4, results='hide', fig.cap="Elements co-occurring where no L1 element is present"}
l1VennCounts <- typeElements %>% 
  filter(L1) %>%
  dplyr::select(-ID, -L1) %>% 
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(l1VennCounts, list(fill = vennCols[-5])))
```



```{r nol1CoPlot, fig.height =4, fig.width=4, results='hide', fig.cap="Elements co-occurring where no L1 element is present"}
l1VennCounts <- typeElements %>% 
  filter(!L1) %>%
  select(-ID, -L1) %>% 
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(l1VennCounts, list(fill = vennCols[-5])))
```


```{r l1Boot, cache=TRUE}
l1Boot <- bootMedians(l1Data, 
                       filter(l1Data, l1)$ID, filter(l1Data, !l1)$ID, 
                       binCol = "other$", valCols = "TPM", nGenes = 1000, nBoot = 1000)
```


```{r l1BootTab, echo=FALSE}
data.frame(P = l1Boot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r l1BootPlot, echo=FALSE, message=FALSE, warning=FALSE}
l1Boot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

## Things for Steve to do
- Make a heatmap of elements by region, using proportions
- Fit a Logistic Regresssion model for prob of elements within a region
- Also explore this idea modelling the rate of appearance within a region...?

# alu Elements By separate regions

First we should see where the *alu* elements are mainly located, ignoring any other TEs which co-occur
```{r aluVenn}
aluRegs <- select(tpmData, ID, contains("alu")) %>%
  mutate(L1 = rowSums(select(tpmData, contains("L1")))) %>%
  mutate(L2 = rowSums(select(tpmData, contains("L2")))) %>%
  mutate(LTR = rowSums(select(tpmData, contains("LTR")))) %>%
  mutate(mir = rowSums(select(tpmData, contains("mir")))) %>%
  sapply(function(x) {if(is.numeric(x)) {as.logical(x)} else {x}}, simplify = FALSE) %>%
  data.frame(stringsAsFactors=FALSE) %>%
  tbl_df
aluRegVennCounts <- aluRegs %>%
  select(contains("alu")) %>%
  getVennCounts()
grid.newpage()
do.call(draw.quad.venn, c(aluRegVennCounts, list(fill = vennCols[-5])))
```

## alu Elements in the CDS
It appears that the `r sum(tpmData$alu_cds_IDs)` genes with an *alu* element in the proximal promoter can be relatively well matched to genes without an *alu* in the proximal promoter.
However, this is a quite small dataset so the number of genes set for ech iteration of the bootstrap was 300.

```{r aluCdsBoot, cache=TRUE}
aluCdsData <- tpmData %>%
  select(-contains("IDs")) %>%
  bind_cols(aluRegs[-1])
aluCdsData$otherBin <- binsFromCols(select(aluRegs, -ID, -alu_cds_IDs), collapse=":")
aluCdsBoot <- bootMedians(aluCdsData, 
                           filter(aluCdsData, alu_cds_IDs)$ID, filter(aluCdsData, !alu_cds_IDs)$ID,
                           binCol = "otherBin$", nBoot=1000, nGenes = 300)
```


All Tissues showed strong evidence of down-regulation due to the presence of an *alu* in the CDS
```{r aluCdsBootTab, echo=FALSE}
data.frame(P = aluCdsBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r aluCdsBootPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluCdsBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

# alu Elements in Proximal Promoters Only

It appears that the `r sum(tpmData$alu_prox_IDs)` genes with an *alu* element in the proximal promoter can be relatively well matched to genes without an *alu* in the proximal promoter.
As this is a larger set of genes, the number chosen for the bootstrap was 1000, as per the default

```{r aluProxBoot, cache=TRUE}
aluProxData <- tpmData %>%
  select(-contains("IDs")) %>%
  bind_cols(aluRegs[-1])
aluProxData$otherBin <- binsFromCols(select(aluRegs, -ID, -alu_prox_IDs), collapse=":")
aluProxBoot <- bootMedians(aluProxData, 
                           filter(aluProxData, alu_prox_IDs)$ID, filter(aluProxData, !alu_prox_IDs)$ID,
                           binCol = "otherBin$", nBoot=1000)
```


All Tissues showed strong evidence of up-regulation due to the presence of an *alu* in the promoter
```{r aluProxBootTab, echo=FALSE}
data.frame(P = aluProxBoot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r aluProxBootPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluProxBoot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

# alu Elements in 3'UTR

It appears that the `r sum(tpmData$alu_utr3_IDs)` genes with an *alu* element in the 3'UTR can be relatively well matched to genes without an *alu* in the 3'UTR.
As this is a larger set of genes, the number chosen for the bootstrap was 1000, as per the default

```{r aluUtr3Boot, cache=TRUE}
aluUtr3Data <- tpmData %>%
  select(-contains("IDs")) %>%
  bind_cols(aluRegs[-1])
aluUtr3Data$otherBin <- binsFromCols(select(aluRegs, -ID, -alu_utr3_IDs), collapse=":")
aluUtr3Boot <- bootMedians(aluUtr3Data, 
                           filter(aluUtr3Data, alu_utr3_IDs)$ID, filter(aluUtr3Data, !alu_utr3_IDs)$ID,
                           binCol = "otherBin$", nBoot=1000)
```


The evidence for up-regulation was less compelling for *alu* elements in the 3'UTR, with Testes in particular showing no effects.
```{r aluUtr3BootTab, echo=FALSE}
data.frame(P = aluUtr3Boot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 3)
```

```{r aluUtr3BootPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluUtr3Boot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```

# alu Elements in 5'UTR

It appears that the `r sum(tpmData$alu_utr5_IDs)` genes with an *alu* element in the 5'UTR can be relatively well matched to genes without an *alu* in the 5'UTR.
As this is also a larger set of genes, the number chosen for the bootstrap was 1000, as per the default.
However, as the 5'UTR region is very element rich, the bias towards genes with all elements being co-identified was very high, and as such, any genes with the combination of L1, L2, LTR & mir was removed.
This left one combination of TEs (alu_cds_IDs:L1:LTR:mir) with a slightly higher than expected sampling probability.
However, as this only affected one gene, giving an expected number in each sample of 1.4/1000 genes, this was ignored, and the maximum permitted p-values was raised to 1/500

```{r aluVenn}
aluUtr5Regs <- select(tpmData, ID, contains("alu_utr5")) %>%
  mutate(L1 = rowSums(select(tpmData, contains("L1")))) %>%
  mutate(L2 = rowSums(select(tpmData, contains("L2")))) %>%
  mutate(LTR = rowSums(select(tpmData, contains("LTR")))) %>%
  mutate(mir = rowSums(select(tpmData, contains("mir")))) %>%
  sapply(function(x) {if(is.numeric(x)) {as.logical(x)} else {x}}, simplify = FALSE) %>%
  data.frame(stringsAsFactors=FALSE) %>%
  tbl_df
aluUtr5RegVennCounts <- aluUtr5Regs %>%
  select(-ID) %>%
  getVennCounts()
grid.newpage()
do.call(draw.quintuple.venn, c(aluUtr5RegVennCounts, list(fill = vennCols)))
```

```{r aluUtr5Boot, cache=TRUE}
aluUtr5Data <- tpmData %>%
  select(-contains("IDs")) %>%
  bind_cols(aluRegs[-1])
aluUtr5Data$otherBin <- binsFromCols(select(aluRegs, -ID, -alu_utr5_IDs), collapse=":")
aluUtr5Boot <- bootMedians(filter(aluUtr5Data, !grepl("L1:L2:LTR:mir", otherBin)),
                           filter(aluUtr5Data, alu_utr5_IDs)$ID, filter(aluUtr5Data, !alu_utr5_IDs)$ID,
                           binCol = "otherBin$", nBoot=1000, maxP=1/500)
```


No evidence of directional influence was found for an *alu* found in the 5'UTR region.
```{r aluUtr5BootTab, echo=FALSE}
data.frame(P = aluUtr5Boot$p) %>% 
  add_rownames("Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue), 
         Tissue = capwords(Tissue)) %>% 
  rename(`P > 0` = P) %>% 
  kable(digits = 5)
```

```{r aluUtr5BootPlot, echo=FALSE, message=FALSE, warning=FALSE}
aluUtr5Boot$samples %>% 
  melt(variable.name="Tissue", value.name = "TPM") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw() +
  geom_vline(x = 0) +
  labs(y = "Density")
```


