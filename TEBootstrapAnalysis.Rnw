\documentclass{article}
\usepackage{underscore}
\usepackage{booktabs}
\usepackage{float}
\usepackage{subfig}
\usepackage{titling}
\usepackage{a4wide}
\usepackage{placeins}
\usepackage{url}
\usepackage{xfrac}

\begin{document}

\title{TE Re-Analysis For Re-Submission,\\
Using the Tilted Bootstrap Approach}
\author{Steve Pederson\\
Adelaide University\\
Bioinformatics Hub}
\maketitle

\section{Workspace Setup}

\subsection*{R Packages}

A number of custom functions were used in this analysis, and these are available in the packages \texttt{spShortcuts} and \texttt{funsForLu}.
These are available on github, and will need to be installed using the following code before loading the required packages.
<<installCustom, eval=FALSE>>=
library(devtools)
install_github("steveped/funsForLu")
install_github("steveped/spShortcuts")
@

<<loadPackages, message=FALSE, warning=FALSE>>=
library(ggplot2)
library(stringr)
library(reshape2)
library(matrixStats)
library(VennDiagram)
library(knitr)
library(xtable)
library(corrplot)
library(scales)
library(pscl)
library(boot)
library(lmtest)
library(dplyr)
library(parallel)
library(funsForLu)
library(spShortcuts)
@

<<knitrSetup, include=FALSE>>=
knit_hooks$set(crop=hook_pdfcrop)
#opts_knit$set(self.contained=FALSE)
opts_chunk$set(fig.align='center', fig.show='as.is', crop=TRUE, include=TRUE, echo=TRUE)
pdf.options(useDingbats=TRUE)
@

\subsection*{Data Loading}

<<loadData, cache=TRUE>>=
tpmFile <- file.path("data", "new_whole_gene_expression_dataset.txt")
tpmData <- read.delim(tpmFile, sep="\t", stringsAsFactors = FALSE) %>% 
  dplyr::select(ID, length, contains("TPM"), contains("IDs")) %>%
  tbl_df
@

The revised data object with read counts as TPM values was then loaded in giving information about TE content and location for \Sexpr{nrow(tpmData)} genes.

<<elements, cache=TRUE, dependson='loadData'>>=
elements <- grep("IDs", colnames(tpmData), value = TRUE) %>% 
  str_split_fixed(pattern="_", 3) %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  dplyr::select(type = V1, region = V2) %>%
  lapply(unique) %>%
  lapply(sort)
@

Logical variables for each element type and region were then added to the main \texttt{data.frame} object.
<<addLog, cache=TRUE, dependson=c('elements', 'loadData')>>=
tpmData <- tpmData %>%
  bind_cols(sapply(unlist(elements) %>% 
                     as.vector, 
                   function(x){dplyr::select(tpmData, contains(x)) %>% 
                                 rowSums %>% 
                                 as.logical},
                   simplify = FALSE))
@

The complete set of tissues was also defined as a character vector.
<<tissues>>=
tissues <- gsub("_TPM", "", grep("TPM", colnames(tpmData), value = TRUE))
@

\section{Data Inspection}
In order to observe the general layout of the data, elements were plotted by type (Figure \ref{fig:plotTypeVenn}) and region.

\subsection{Inspection By Element Type}
<<typeVenn>>=
vennCols <- c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3")
noElCount <- paste("No elements in gene:", 
                   nrow(filter(tpmData, !alu, !L1, !L2, !LTR, !mir)))
typeVenn <- tpmData %>% 
  dplyr::select(one_of(elements$type)) %>%
  getVennCounts
@

<<plotTypeVenn, echo=FALSE, results='hide', fig.cap='Element types and their co-occurrences', crop=FALSE>>=
grid.newpage()
do.call(draw.quintuple.venn, c(typeVenn, list(fill = vennCols)))
grid.text(noElCount, 0.05, 0.85, just = "left")
grid.text(paste0("Total genes: ", nrow(tpmData)), 0.05, 0.8, just="left")
@

From Figure \ref{fig:plotTypeVenn} it is very clear that many genes (\Sexpr{typeVenn$n12345}) contain all 5 elements, and this number far surpasses the numbers of any elements found in isolation.

<<elementSummary>>=
singleElements <- lapply(seq_along(elements$type),
                         function(x){filter_(tpmData, 
                                             elements$type[x], 
                                             paste(paste0("!", elements$type[-x]), 
                                                   collapse = " & "))["ID"]})
names(singleElements) <- elements$type
elementSummary <- data_frame(Type = elements$type,
                             Single = vapply(singleElements, 
                                             nrow, 
                                             integer(1)),
                             Total = vapply(Type, 
                                            function(x){filter_(tpmData, x) %>% nrow}, 
                                            integer(1)),
                             Proportion = Single / Total)
@

<<elementSummaryXtab, echo=FALSE, results='asis'>>=
elementSummary %>%
  dplyr::select(`Element Type` = Type,
         Total,
         `Found In Isolation` = Single,
         Proportion) %>%
  xtable(digits = c(0, 0, 0, 0, 3),
         caption = paste("Summary of each TE type, and how many are found with no other elements, i.e. in isolation.",
                         "The proportion refers to those found in isolation"),
         label = "tab:elSumm") %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

\subsection{Inspection By Region}
A similar approach was taken to view the data structure broken down by genomic region.

<<regionVenn, results='hide', fig.cap="Genomic regions, and the distribution of TE's within them">>=
regionVenn <- tpmData %>% 
  dplyr::select(one_of(elements$region)) %>%
  getVennCounts
grid.newpage()
do.call(draw.quad.venn, c(regionVenn, list(fill = vennCols[-5])))
grid.text(noElCount, 0.05, 0.92, just = "left")
grid.text(paste0("Total genes: ", nrow(tpmData)), 0.05, 0.88, just="left")
@

From Figure \ref{fig:regionVenn} it is very clear that TEs are less commonly found in the CDS region of a gene, which make immediate intuitive sense.
In contrast to the previous section, a much greater proportion of genes only contained elements in a single region

<<regionSummary>>=
singleRegion <- lapply(seq_along(elements$region),
                       function(x){filter_(tpmData, 
                                           elements$region[x], 
                                           paste(paste0("!", elements$region[-x]), 
                                                 collapse = " & "))["ID"]})
names(singleRegion) <- elements$region
regionSummary <- data_frame(Region = elements$region,
                             Single = vapply(singleRegion, 
                                             nrow, 
                                             integer(1)),
                             Total = vapply(Region, 
                                            function(x){filter_(tpmData, x) %>% nrow}, 
                                            integer(1)),
                             Proportion = Single / Total)
@

<<regionSummaryXtab, echo=FALSE, results='asis'>>=
regionSummary %>%
  dplyr::select(Region, Total,
         `Elements In Single Region` = Single,
         Proportion) %>%
  xtable(digits = c(0, 0, 0, 0, 3),
         caption = paste("Summary of each genomic region, and how many are found with elements in one region only.",
                         "The proportion refers to those genes with TEs in only a single region."),
         label = "tab:regSumm") %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

\subsection{Distribution of Elements within Regions}
The association of each element with each other across the various regions was also explored (Figure \ref{fig:corrplot}), with the striking observation that many genes contain each element within the 5'UTR.
Overall, a total of \Sexpr{(tpmData %>% dplyr::select(contains("utr5_IDs")) %>% rowSums %>% table)[6]} genes contained each element type in this region.

<<corrplot, echo=FALSE, fig.cap="Correlation plot, showing the frequencies of co-occurrence for each element type, broken down by region. The strong correlation between each element type in the 5'UTR is the most clear pattern, with somewhat lesser numbers of genes showinf a similar patter in the 3'UTR and proximal promoter.">>=
elRegs <- sort(grep("IDs", colnames(tpmData), value = TRUE))
tpmData %>% 
  dplyr::select(one_of(elRegs)) %>%
  cor %>%
  corrplot(method = "shade")
@

The breakdown of each element type within each region is also shown as a proportion in Table \ref{tab:regProps} and Figure \ref{fig:plotRegProps}.
The most common elements were clearly alu, mir and L2s, with the 5'UTRs showing the most common appearances of all motifs.

<<regPropsXtab, echo=1, results='asis'>>=
regionProps <- elements$region %>%
  sapply(function(x){
    filter_(tpmData, x) %>% summarise_each(funs(mean), one_of(elements$type)) 
  },simplify = FALSE) %>%
  bind_rows %>%
  mutate(Region = elements$region) %>%
  dplyr::select(Region, one_of(elements$type)) 
regionProps %>%
  xtable(digits = 3,
         caption = paste("Proportion of each region containing each element."),
         label = "tab:regProps") %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<plotRegProps, echo=FALSE, fig.height=5, fig.cap="Proportions of each region containing each element.">>=
regionProps %>%
  melt(id.vars = "Region", variable.name = "Type", value.name = "Proportion") %>%
  ggplot(aes(x = Region, y = Type, fill = Proportion)) +
  geom_raster() +
  scale_fill_gradient(low = "white", high = muted("blue"), limits = c(0.25, 0.9)) +
  theme_bw() +
  labs(y = "Element Type")
@

\FloatBarrier
\section{Data Analysis}
\subsection{Transposable Elements With No Co-occurring Elements}
The initial stages of each analysis were to take the sets of genes with each element in isolation, and determine whether each element has any detectable influence on the overall gene expression.
To generate the plots for this analysis, the data was restructured from wide to long format.
<<longData, cache=TRUE, cache=TRUE, dependson=c('loadData', 'elements', 'addLog')>>=
longData <- tpmData %>%
  melt(id.vars = c("ID", "length", elements$type), 
       measure.vars = paste0(tissues, "_TPM"), 
       value.name = "TPM", 
       variable.name = "Tissue") %>% 
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue),
         TE = as.logical(alu + L1 + L2 + LTR + mir),
         rawTPM = as.integer(round(exp(TPM)*100, 0))) %>%
  tbl_df
@

The number of genes included with a raw TPM value $=0$ (i.e. prior to log transformation) were also noted for each tissue type in Table \ref{tab:notExp}, with a clear enrichment in each dataset for genes with TPM $=0$.
Any subsequent analysis using a negative binomial distribution should be zero-inflated as a result of this observation.\\
\\
As is also seen in Figure \ref{fig:plotTissues}, the general range of expression values is much lower in Liver than for the other tissues.

<<xtabNotExp, echo=FALSE, results='asis', message=FALSE >>=
longData %>% 
  filter(TPM == -Inf) %>% 
  count_(c("Tissue", "TE")) %>% 
  dcast(Tissue~TE) %>% 
  dplyr::select(Tissue, `No TE` = `FALSE`, `TE Present` = `TRUE`) %>% 
  mutate(`Prop. No TE` = `No TE` / length(unique(filter(longData, !TE)$ID)),
         `Prop. TE` = `TE Present` / length(unique(filter(longData, TE)$ID)),
         Total = `No TE` + `TE Present`,
         `Prop. Of All Genes` = Total / nrow(tpmData)) %>%
  dplyr::select(Tissue, `No TE`, `Prop. No TE`, 
                `TE Present`, `Prop. TE`,
                Total, `Prop. Of All Genes` ) %>%
  xtable(caption = paste("Numbers and proportions of genes in each Tissue which were not expressed, i.e. where TPM = 0.",
                         "The presence or absence of a TE is also indicated in the summaries."),
         label = "tab:notExp",
         digits = c(0, 0, 0, 3, 0, 3, 0, 3)) %>%
  print(caption.placement = "top",
        include.rownames = FALSE, 
        size = "small")
@


<<plotTissues, echo = FALSE, fig.height=5, fig.cap="Distribution of log(TPM) values for each tissue type.">>=
longData %>%
  filter(TPM > -Inf) %>%
  ggplot(aes(x = Tissue, y = TPM, fill = Tissue)) +
  geom_boxplot() +
  theme_bw() +
  guides(fill = FALSE) +
  labs(y = "log(TPM)")
@

\subsection*{Fitting Using a Zero-Inflated Negative Binomial}
The action of each element alone was first investigated using a zero-inflated negative binomial distribution.
This approach explicitly models two distributions:\\
\begin{enumerate}
  \item The probability of not obtaining a zero value for the count
  \item The probability distribution of the counts, given they are non-zero
\end{enumerate}

In this way we can model the impacts of each isolated TE on the probability of expression, as well as the impacts on expression levels.
Two models were initially fitted, the first including Tissue \& TE interactions in the probability side of the model, the second, without these interactions.


<<fitAllZINB, cache=TRUE, dependson=c('loadData', 'elements', 'addLog', 'longData')>>=
singleData <- longData %>% 
  mutate(TEtype = binsFromCols(dplyr::select(longData, one_of(elements$type)))) %>%
  filter(TEtype %in% c(elements$type, "none")) %>%
  mutate(TEtype  = factor(TEtype, levels= c("none", elements$type)))
fitSingleElementsInt <- hurdle(rawTPM ~ 0 + Tissue*TEtype + log(length) |
                                 0 + Tissue*TEtype + log(length),
                               data = singleData, dist = "negbin")
fitSingleElementsNoInt <- hurdle(rawTPM ~ 0 + Tissue*TEtype + log(length) | 
                                   0 + Tissue + TEtype + log(length),
                               data = singleData, dist = "negbin")
@

These models were checked for a goodness of fit using the likelihood ratio test, with no discernible difference between the two models.
For simplicity the model with no Tissue/TE interactions within the probability side of the model was selected.

<<lrTest, cache=TRUE, dependson='fitAllZINB'>>=
lrtest(fitSingleElementsNoInt, fitSingleElementsInt )
@

<<negBinProbCoefs, echo=FALSE,results='asis'>>=
summary(fitSingleElementsNoInt)$coef$zero %>% 
  as.data.frame() %>% 
  add_rownames("Term") %>% 
  mutate(Term = gsub("TEtype", "", Term), 
         Term = gsub("Tissue", "", Term),
         adjP = p.adjust(`Pr(>|z|)`, "bonferroni"), 
         Sig = aster(adjP)) %>%
  xtable(digits = c(0, 0, 3, 3, 3, -3, -3, 0), 
         caption = "Coefficients from the Probability side of the zero-inflated negative bionomial model",
         label = "tab:negBinProbCoefs") %>% 
  print(caption.placement = "top", 
        include.rownames = FALSE)
@

As can be seen in Table \ref{tab:negBinProbCoefs}, both alu and L2 elements strongly increase the probability of a gene being detected as expressed.
LTR elements have strongly negative impact on the probability of being detected as expressed.
L1 and mir elements have weakly negative and positive influences respectively.

In order to better understand the given coefficients in Table \ref{tab:negBinProbCoefs}, for a 2.5kb gene in Adipose tissue with an alu element, the estimated probability ($\hat{\pi}$) of being detected as expressed would be:\\
\\
\begin{tabular}{ll}
  $\hat{\pi}$ &= Inv-logit (\Sexpr{format(summary(fitSingleElementsNoInt)$coef$zero[1, 1], digits =4)} + 
  \Sexpr{format(summary(fitSingleElementsNoInt)$coef$zero[7, 1], digits=4)} + \Sexpr{format(summary(fitSingleElementsNoInt)$coef$zero[12, 1], digits =4)} $\times \log$ 2500 ) \\
            & = 0.7490 \\
\end{tabular}\\
\\
For the count component of the model, all baseline changes due to an element are expressed by default in reference to Adipose Tissue (Table \ref{tab:negBinRateCoef}).
\begin{itemize}
  \item L1, LTR and mir elements are all associated with a reduction in counts for Adipose Tissue, whilst alu and L2 elements appear to have no effect. 
  \item alu elements in Brain and Skeletal Muscle appear to have a repressive effect in comparison to that observed in Adipose Tissue
  \item In Liver, the repressive effect of the L1 elements appear to be reversed, whilst in Skeletal Muscle the repressive effect is enhanced
  \item In Liver L2s appear to be associated with up-regulation
  \item In Liver, the repressive effects of LTRs appear to be reversed. Likewise for Skeletal Muscle
  \item In Liver, mirs appear to be associated with up-regulation.
\end{itemize}

The interpretation of the above needs careful thought. 
All interaction terms between tissue and an element are in reference to the baseline, and indicate that the observed effects exceed what would be expected if no interaction was observed.
The regular reduction in repressive function for elements in Liver, may not actually be due to a loss of repressive effect, but may instead be an artefact of the lower overall range of TPM values.
Notably, Skeletal Muscle was also seen with elements having their repressive effects reversed.
Both of these tissues had the highest proportions overall of undetectable genes (Table \ref{tab:notExp}).
An alternative way to investigate this would be to fit each tissue separately.\\

It should also be noted than in the prior bootstrapping approach, the median expression value was used for calculations, which included not-expressed amongst the expressed values.
The negative binomial approach effectively separates the not-expressed and the expressed genes, in an somewhat analogous method to the k-means approach.
The increase in probability of detection, coupled with a repressive effect for many TEs does appear to be somewhat contradictory, at least on the surface.
The superiority of one approach over the other is not immediately clear.

<<negBinRateCoefs, echo=FALSE,include=TRUE,results='asis'>>=
summary(fitSingleElementsNoInt)$coef$count %>% 
  as.data.frame() %>% 
  add_rownames("Term") %>% 
  rename(Pval = `Pr(>|z|)`) %>%
  mutate(adjP = p.adjust(Pval, "bonferroni"), 
         Sig = aster(adjP), 
         Term = gsub("TEtype", "", Term), 
         Term = gsub("Tissue", "", Term)) %>% 
  xtable(digits = c(0, 0, 2, 2, 2, -2, -2, 0),
         caption = "Count Coefficients for the Negative Binomial Model",
         label = "tab:negBinRateCoef") %>%
  print(include.rownames=FALSE,
        caption.placement = "top",
        booktabs = TRUE,
        add.to.row = list(pos = c(6, 11, 12, as.list(seq(17, 38, by=5 ))),
                          command = rep("\\midrule\n",8)))
@

\FloatBarrier
\subsection{Fitting each tissue separately}

<<tissueW, cache=TRUE, dependson=c('loadData', 'fitAllZINB')>>=
tissueComps <- tissues %>% 
  capwords %>% 
  combn(2)
tissueW <- apply(tissueComps, MARGIN = 2, 
                 FUN = function(x){wilcox.test(rawTPM ~ Tissue, 
                                          data = filter(singleData, 
                                                        rawTPM > 0, 
                                                        Tissue %in% x) %>% 
                                            mutate(rawTPM = rawTPM -1) %>% 
                                            select(rawTPM, Tissue))})
@

<<xTabTissueW, echo=FALSE, include=TRUE, results='asis'>>=
tissueW %>% 
  lapply(function(x){data_frame(W = x$statistic,  
                                p = x$p.value)}) %>% 
  bind_rows %>%
  mutate(Comparison = paste(tissueComps[1,], 
                            tissueComps[2,], 
                            sep = " Vs. "),
         adjP = p.adjust(p, "bonferroni"),
         Sig = aster(adjP)) %>%
  select(Comparison, W, p, adjP, Sig) %>%
  xtable(digits = c(0, 0, 0, -2, -2, 0),
         label = "tab:tissueW",
         caption = paste("Tests for distributional homogeneity across tissues, using a Wilcoxon-test.",
                         "Adjusted p-values generated using Bonferroni's adjustment.")) %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

The above results also raised the possibility that the TPM distributions were not constant between tissues.
This was tested in a pairwise context using a Wilcoxon-test.
Results are shown in Table \ref{tab:tissueW}, and considerable variability was noted with the exceptions of Brain, Kidney \& Testes
As such, each tissue was fitted individually, which also allowed for fitting of any tissue-specific effects of gene-length. \\

<<fitTissueNB, cache=TRUE, dependson=c('loadData', 'elements', 'addLog', 'longData')>>=
singleTissueNBFits <- tissues %>%
  capwords %>%
  sapply(function(x){hurdle(rawTPM ~ TEtype + log(length),
                            data = singleData, 
                            subset = Tissue==x,
                            dist = "negbin")},
         simplify = FALSE)
@

\subsubsection*{Effects on the Probability of Expression}
In order to ascertain any tissue-specific TE effects on the probability of expression, 95\% confidence intervals were plotted for each element in each tissue.
As there were 5 elements across 6 tissues, the intervals were generated using a Bonferroni-adjusted critical value ($Z = $\Sexpr{-qnorm(0.025/30)}), which corresponds to , $\alpha = \sfrac{0.05}{30}$.

<<zeroConfInt>>=
critVal <- -qnorm(0.025/30)
zeroConfInt <- names(singleTissueNBFits) %>%
  lapply(function(x){data.frame(summary(singleTissueNBFits[[x]])$coef$zero) %>%
                       add_rownames("TE") %>%
                       filter(grepl("TEtype", TE)) %>%
                       mutate(Tissue = x)}) %>%
  bind_rows() %>%
  select(Tissue, TE, Estimate, se = contains("Std")) %>%
  mutate(TE  = gsub("TEtype", "", TE),
         lower = Estimate - critVal*se,
         upper = Estimate + critVal*se)
@

As seen in Figure \ref{fig:plotZeroConfInt}:
\begin{itemize}
  \item alu elements consistently increased the probability of being expressed across all tissues
  \item L1 elements were inconsistent in their effects, with a potential bias towards genes not being expressed, most strongly observed in Skeletal Muscle
  \item L2 elements showed evidence of an increased probability of expression in Skeletal Muscle, Kidney and Brain. A similar bias was also seen in the other tissues, whilst not formally achieving significance
  \item LTR elements showed evidence of a reduced probability of expression in Skeletal Muscle only, however this negative bias was also evident in all other tissues.
  \item mir elements were also inconclusive with respect to the probability of being expressed
\end{itemize}

<<plotZeroConfInt, echo=FALSE, fig.height=6, fig.cap="95\\% Confidence Intervals on the logit scale for the tissue-specific effects on the probability of expression. All values are in comparison to the tissue sepcific baseline probability of expression for genes with no TEs, and all intervals used a Bonferroni-adjusted critical value. The zero-line, indicative of no effect is shown as a dotted grey line.">>=
zeroConfInt %>%
  ggplot(aes(x = Estimate, y = Tissue)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower, xmax = upper), 
                 height = 0.7) +
  geom_vline(x = 0, colour = "grey50", linetype=2) +
  theme_bw() +
  labs(x = "Change in p(Expression) from baseline", 
       y = "Tissue") + 
  facet_wrap(~TE, nrow = 3) 
@

As no tissue specific effects were clearly observable in Figure \ref{fig:plotZeroConfInt}, the tissue-specific model was deemed inappropriate for the probability of expression, and the results given in Table \ref{tab:negBinProbCoefs} should be considered as the most representative.

\subsubsection{Effects on the Rate of Expression}

<<countConfInt>>=
critVal <- -qnorm(0.025/30)
countConfInt <- names(singleTissueNBFits) %>%
  lapply(function(x){data.frame(summary(singleTissueNBFits[[x]])$coef$count) %>%
                       add_rownames("TE") %>%
                       filter(grepl("TEtype", TE)) %>%
                       mutate(Tissue = x)}) %>%
  bind_rows() %>%
  select(Tissue, TE, Estimate, se = contains("Std")) %>%
  mutate(TE  = gsub("TEtype", "", TE),
         lower = Estimate - critVal*se,
         upper = Estimate + critVal*se)
@

<<plotCountConfInt, echo=FALSE, fig.height=6, fig.cap="95\\% Confidence Intervals for the tissue-specific effects on the rates of expression counts. All values are in comparison to the tissue sepcific baseline rate of expression for genes with no TEs, and all intervals used a Bonferroni-adjusted critical value. The zero-line, indicative of no effect is shown as a dotted grey line.">>=
countConfInt %>%
  ggplot(aes(x = Estimate, y = Tissue)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower, xmax = upper), 
                 height = 0.7) +
  geom_vline(x = 0, colour = "grey50", linetype=2) +
  theme_bw() +
  labs(x = "Change in expression from baseline", 
       y = "Tissue") + 
  facet_wrap(~TE, scales = "free_x", nrow = 3) 
@

Bonferroni-adjusted confidence intervals were then generated for the effects of each TE on the overall levels of expression (Figure \ref{fig:plotCountConfInt}).
\begin{itemize}
  \item alu elements showed a bias towards up-regulation in Adipose Tissue, Kidney, Liver and Testes, although this was clearly not significant. 
  In Brain and Skeletal Muscle, this effect was clearly in the opposite direction, with this bias towards inhibition of expression being statistically significant in Brain Tissue only.
  \item L1 elements showed a significant inhibitory influence in all tissues except Liver, were they showed exhibited a strong positive influence on expression.
  \item L2 elements showed a negative bias only in Adipose Tissue and Testes, with a significant inhibitory effect in Brain, Kidney and Skeletal Muscle.
  In Liver, this effect was reverse and L2 elements appeared to have a positive impact on gene expression
  \item LTR elements were significantly inhibitory in all tissues except Liver and Skeletal Muscle, where they had no discernible influence at all.
  \item mir elements also had a significant inhibitory influence in all tissues except Liver, where they appeared to have a positive influence on gene expression.
\end{itemize}

These elements consistently showed differing impacts on gene expression in Liver, which was somewhat surprising.
However, given the lower overall expression levels observed in Figure \ref{fig:plotTissues} this may be an artefact of the different structure of this data.
All model parameters not directly related to TEs showed this different behaviour as well (Table \ref{tab:modelParams}).
In this table, all parameter estimates for liver had noticeably higher standard errors, and the over-dispersion parameter $\theta$ was also considerably lower, indicating greater over-dispersion.
Similarly, the effects of gene length (taken on the log scale) were that longer genes showed a greater level of reduced expression in this tissue.
Whether this was a biological phenomenon or a technical artefact is unclear.


<<modelParams, echo=FALSE, include=TRUE, results='asis'>>=
singleTissueNBFits %>% 
     sapply(function(x){summary(x)$coef$count[c("(Intercept)", "log(length)", "Log(theta)"),c("Estimate", "Std. Error")]}) %>% 
  t %>% 
  xtable(digits = c(0, 2, 2, 2, 3, 3, 3),
         align = "|l|rrr|rrr|", 
         label="tab:modelParams",
         caption = "Estimates of general model parameters from tissue-specific model fitting.") %>%
  print(include.colnames = FALSE,
        caption.placement = "top",
        add.to.row = list(pos = list(0),
                          command = paste("& \\multicolumn{3}{|c|}{Estimates} & \\multicolumn{3}{|c|}{Std. Errors}\\\\",
                                          "\\cline{2-7}",
                                          paste(c("Tissue", "$\\mu$", "log(length)", "log($\\theta$)",
                                                  "$\\mu$", "log(length)", "log($\\theta$) \\\\"),
                                                collapse = " & "))))
@

\subsubsection{Brief Comments}
It must be restated that the above analysis was on gene with either a single element, or no elements.
This represents less than 20\% of the occurrences of each element (Table \ref{tab:elSumm}), and may be highly unrepresentative on a genome-wide scale.\\

Additionally, the above relied on fitting the data via a zero-inflated negative binomial model, which fits count data on the linear scale.
By using the hurdle approach, any zero-values for TPM were effectively removed from the model fitting stage.
This is a parametric model and relies on behaviour that can be well modelled by the explicit model assumptions.


\FloatBarrier
\section{Single Elements Using the Bootstrap Approach}
<<lengthBins>>=
nBins <- 10
nBoot <- 10000L
lengthBins <- quantile(tpmData$length, probs = seq(0, 1, length.out = nBins + 1))
tpmData <- mutate(tpmData, 
                  lengthBin = findInterval(length, lengthBins, rightmost.closed=TRUE))
@

As noted above, the excessive over-dispersion observed in the Liver sample may have had an impact of the model fitting stages.
As an alternative to this approach, the sets of genes with a single element were bootstrapped against those genes with no elements, in a Tissue specific manner using length as the binning variable, as with the previous approach.
Each dataset was bootstrapped \Sexpr{nBoot} times.

<<plotTissueTPM, fig.height=4, fig.cap="Comparison of TPM distributions based on presence of a single TE. TPM values are shown on the log scale, with non-expressed genes removed.">>=
singleData %>% 
  filter(TPM>-Inf) %>% 
  ggplot(aes(x=TPM, fill=TE))+
  geom_density(alpha=0.5)+
  facet_wrap(~Tissue) +
  theme_bw() +
  labs(x = "log(TPM)", y = "Density")
@



\subsection{Alu Elements in Isolation}
The genes with alu elements in isolation, were bootstrapped against the genes with no elements, binning the genes based on their length.
<<bootSingleAlu, cache = TRUE>>=
bootSingleAlu <- mclapply(tissues, bootMeans, 
                          data = tpmData, 
                          testIds = filter(tpmData, alu, !L1, !L2, !LTR, !mir)$ID, 
                          refIds = filter(tpmData, !alu, !L1, !L2, !LTR, !mir)$ID,
                          nBoot = nBoot, 
                          nGenes = 1000L)
names(bootSingleAlu) <- tissues
@

<<plotBootAluOnly, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with Alu elements in isolation when compared to genes with no TEs.">>=
vapply(bootSingleAlu, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

As seen in Figure \ref{fig:plotBootAluOnly}, Adipose Tissue and Testes agree with the previous analysis using a negative binomial (Figure \ref{fig:plotCountConfInt}), whilst Skeletal muscle obtained the completely opposite result.
Brain tissue was inconclusive, whilst showing clear down-regulation under the negative binomial model.
Kidney and Liver were directionally consistent with the NB approach, although significance was clearly observed under the bootstrap approach.

\subsection{L1 Elements in Isolation}
The genes with L1 elements in isolation, were bootstrapped against the genes with no elements, binning the genes based on their length.
<<bootSingleL1, cache = TRUE>>=
bootSingleL1 <- mclapply(tissues, bootMeans, 
                          data = tpmData, 
                          testIds = filter(tpmData, !alu, L1, !L2, !LTR, !mir)$ID, 
                          refIds = filter(tpmData, !alu, !L1, !L2, !LTR, !mir)$ID,
                          nBoot = nBoot, 
                          nGenes = 1000L)
names(bootSingleL1) <- tissues
@

<<plotBootL1Only, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L1 elements in isolation when compared to genes with no TEs.">>=
vapply(bootSingleL1, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

As seen in Figure \ref{fig:plotBootL1Only}, most of the results agree with the previous analysis using a negative binomial (\ref{fig:plotCountConfInt}), with a clear negative effect on gene expression.
The previously observed up-regulation in Brain Tissue, was not seen under this approach however, and the results for Testes were less statistically significant.

\subsection{L2 Elements in Isolation}
The genes with L2 elements in isolation, were bootstrapped against the genes with no elements, binning the genes based on their length.
<<bootSingleL2, cache = TRUE>>=
bootSingleL2 <- mclapply(tissues, bootMeans, 
                          data = tpmData, 
                          testIds = filter(tpmData, !alu, !L1, L2, !LTR, !mir)$ID, 
                          refIds = filter(tpmData, !alu, !L1, !L2, !LTR, !mir)$ID,
                          nBoot = nBoot, 
                          nGenes = 1000L)
names(bootSingleL2) <- tissues
@

<<plotBootL2Only, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L2 elements in isolation when compared to genes with no TEs.">>=
vapply(bootSingleL2, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

As seen in Figure \ref{fig:plotBootL2Only}, no significant difference in the means was observed, as compared with the previous analysis using a negative binomial (\ref{fig:plotCountConfInt}), where these elements showed significant down-regulation in Brain, Kidney and Skeletal Muscle, and up-regulation in Liver

\subsection{LTR Elements in Isolation}
The genes with LTR elements in isolation, were bootstrapped against the genes with no elements, binning the genes based on their length.
<<bootSingleLTR, cache = TRUE>>=
bootSingleLTR <- mclapply(tissues, bootMeans, 
                          data = tpmData, 
                          testIds = filter(tpmData, !alu, !L1, !L2, LTR, !mir)$ID, 
                          refIds = filter(tpmData, !alu, !L1, !L2, !LTR, !mir)$ID,
                          nBoot = nBoot, 
                          nGenes = 1000L)
names(bootSingleLTR) <- tissues
@

<<plotBootLTROnly, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with LTR elements in isolation when compared to genes with no TEs.">>=
vapply(bootSingleLTR, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

As seen in Figure \ref{fig:plotBootLTROnly}, the results were broadly consistent when compared with the previous analysis using a negative binomial (\ref{fig:plotCountConfInt}).
Most Tissues showed significant down-regulation, however the previously observed lack of down-regulation in Liver and Skeletal Muscle was once again evident.

\subsection{mir Elements in Isolation}
The genes with mir elements in isolation, were bootstrapped against the genes with no elements, binning the genes based on their length.
<<bootSingleMir, cache = TRUE>>=
bootSingleMir <- mclapply(tissues, bootMeans, 
                          data = tpmData, 
                          testIds = filter(tpmData, !alu, !L1, !L2, !LTR, mir)$ID, 
                          refIds = filter(tpmData, !alu, !L1, !L2, !LTR, !mir)$ID,
                          nBoot = nBoot, 
                          nGenes = 1000L)
names(bootSingleMir) <- tissues
@

<<plotBootMirOnly, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with mir elements in isolation when compared to genes with no TEs.">>=
vapply(bootSingleMir, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

As seen in Figure \ref{fig:plotBootmirOnly}, no tissues except for Testes showed any significant effects due to the presence of mir elements, as compared with the previous analysis using a negative binomial (Figure \ref{fig:plotCountConfInt}), where significant down-regulation was observed in all tissues except Liver.

\subsection{Summary of Results for Single Elements}

<<allSingleBoot, echo=FALSE, include=TRUE, results='asis'>>=
vapply(bootSingleAlu, function(x){x$p}, numeric(1)) %>%
  as.data.frame() %>%
  add_rownames("Tissue") %>%
  select(Tissue, alu = contains(".")) %>%
  mutate(Tissue = capwords(Tissue),
         L1 = vapply(bootSingleL1, function(x){x$p}, numeric(1)),
         L2 = vapply(bootSingleL2, function(x){x$p}, numeric(1)),
         LTR = vapply(bootSingleLTR, function(x){x$p}, numeric(1)),
         mir = vapply(bootSingleMir, function(x){x$p}, numeric(1))) %>%
  xtable(digits = 4,
         caption = "Bootstrapped p-values for Elements acting in isolation for each tissue type",
         align = "llrrrrr",
         label = "tab:allSingleBoot") %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

\section{Elements in the Presence of Up To One Additional Element}
The impacts on the addition of one accompanying element were then investigated to increase the sample size \& gain a clearer picture of the wider genome.\\

\subsection{Alu Elements In the presence of Up To One Additional Element}
<<aluPlusOneData>>=
aluPlusOneData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("alu", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_", elBins))
countsAluPlusOne <- count(aluPlusOneData, alu, elBins) %>% 
  dcast(elBins~alu, value.var = "n") 
@

<<xtabAluPlusOneData, echo=FALSE, include=TRUE, results='asis'>>=
countsAluPlusOne %>% 
  rename(`Additional Element` = elBins,
         `Genes without an alu` = `FALSE`, 
         `Genes with an alu` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for alu elements, allowing up to one extra element.",
         label = "tab:aluPlusOne",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootAluPlusOne, cache=TRUE>>=
bootAluPlusOne <- mclapply(tissues, bootMeans, 
                           data = aluPlusOneData, 
                           testIds = filter(aluPlusOneData, alu)$ID, 
                           refIds = filter(aluPlusOneData, !alu)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootAluPlusOne) <- tissues
@

<<plotAluPlusOne, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with Alu elements in isolation when compared to genes with no TEs.">>=
vapply(bootAluPlusOne, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:aluPlusOne}, and the results of the bootstrapping procedure (Figure \ref{fig:plotAluPlusOne}) are highly consistent with those from alu elements acting in isolation (Figure \ref{fig:plotBootAluOnly}).

\subsection{L1 Elements In the presence of Up To One Additional Element}
<<L1PlusOneData, message=FALSE>>=
L1PlusOneData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("L1", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_", elBins))
countsL1PlusOne <- count(L1PlusOneData, L1, elBins) %>% 
  dcast(elBins~L1, value.var = "n") 
@

<<xtabL1PlusOneData, echo=FALSE, include=TRUE, results='asis'>>=
countsL1PlusOne %>% 
  rename(`Additional Element` = elBins,
         `Genes without an L1` = `FALSE`, 
         `Genes with an L1` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for L1 elements, allowing up to one extra element.",
         label = "tab:L1PlusOne",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootL1PlusOne, cache=TRUE>>=
bootL1PlusOne <- mclapply(tissues, bootMeans, 
                           data = L1PlusOneData, 
                           testIds = filter(L1PlusOneData, L1)$ID, 
                           refIds = filter(L1PlusOneData, !L1)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootL1PlusOne) <- tissues
@

<<plotL1PlusOne, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L1 elements in isolation when compared to genes with no TEs.">>=
vapply(bootL1PlusOne, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:L1PlusOne}, and the results of the bootstrapping procedure (Figure \ref{fig:plotL1PlusOne}) are highly consistent with those from L1 elements acting in isolation (Figure \ref{fig:plotBootL1Only}).

\subsection{L2 Elements In the presence of Up To One Additional Element}
<<L2PlusOneData, message=FALSE>>=
L2PlusOneData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("L2", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_", elBins))
countsL2PlusOne <- count(L2PlusOneData, L2, elBins) %>% 
  dcast(elBins~L2, value.var = "n") 
@

<<xtabL2PlusOneData, echo=FALSE, include=TRUE, results='asis'>>=
countsL2PlusOne %>% 
  rename(`Additional Element` = elBins,
         `Genes without an L2` = `FALSE`, 
         `Genes with an L2` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for L2 elements, allowing up to one extra element.",
         label = "tab:L2PlusOne",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootL2PlusOne, cache=TRUE>>=
bootL2PlusOne <- mclapply(tissues, bootMeans, 
                           data = L2PlusOneData, 
                           testIds = filter(L2PlusOneData, L2)$ID, 
                           refIds = filter(L2PlusOneData, !L2)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootL2PlusOne) <- tissues
@

<<plotL2PlusOne, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L2 elements in isolation when compared to genes with no TEs.">>=
vapply(bootL2PlusOne, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:L2PlusOne}, and the results of the bootstrapping procedure (Figure \ref{fig:plotL2PlusOne}) are highly consistent with those from L2 elements acting in isolation (Figure \ref{fig:plotBootL2Only}).

\subsection{LTR Elements In the presence of Up To One Additional Element}
<<LTRPlusOneData, message=FALSE>>=
LTRPlusOneData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("LTR", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_", elBins))
countsLTRPlusOne <- count(LTRPlusOneData, LTR, elBins) %>% 
  dcast(elBins~LTR, value.var = "n") 
@

<<xtabLTRPlusOneData, echo=FALSE, include=TRUE, results='asis'>>=
countsLTRPlusOne %>% 
  rename(`Additional Element` = elBins,
         `Genes without an LTR` = `FALSE`, 
         `Genes with an LTR` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for LTR elements, allowing up to one extra element.",
         label = "tab:LTRPlusOne",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootLTRPlusOne, cache=TRUE>>=
bootLTRPlusOne <- mclapply(tissues, bootMeans, 
                           data = LTRPlusOneData, 
                           testIds = filter(LTRPlusOneData, LTR)$ID, 
                           refIds = filter(LTRPlusOneData, !LTR)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootLTRPlusOne) <- tissues
@

<<plotLTRPlusOne, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with LTR elements in isolation when compared to genes with no TEs.">>=
vapply(bootLTRPlusOne, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:LTRPlusOne}, and the results of the bootstrapping procedure (Figure \ref{fig:plotLTRPlusOne}) are highly consistent with those from LTR elements acting in isolation (Figure \ref{fig:plotBootLTROnly}).

\subsection{mir Elements In the presence of Up To One Additional Element}
<<mirPlusOneData, message=FALSE>>=
mirPlusOneData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("mir", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_", elBins))
countsMirPlusOne <- count(mirPlusOneData, mir, elBins) %>% 
  dcast(elBins~mir, value.var = "n") 
@

<<xtabMirPlusOneData, echo=FALSE, include=TRUE, results='asis'>>=
countsMirPlusOne %>% 
  rename(`Additional Element` = elBins,
         `Genes without a mir` = `FALSE`, 
         `Genes with a mir` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for mir elements, allowing up to one extra element.",
         label = "tab:mirPlusOne",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootMirPlusOne, cache=TRUE>>=
bootMirPlusOne <- mclapply(tissues, bootMeans, 
                           data = mirPlusOneData, 
                           testIds = filter(mirPlusOneData, mir)$ID, 
                           refIds = filter(mirPlusOneData, !mir)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootMirPlusOne) <- tissues
@

<<plotMirPlusOne, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with mir elements in isolation when compared to genes with no TEs.">>=
vapply(bootMirPlusOne, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:mirPlusOne}, and the results of the bootstrapping procedure (Figure \ref{fig:plotMirPlusOne}) are highly consistent with those from mir elements acting in isolation (Figure \ref{fig:plotBootMirOnly}).

\subsection{Summary of Results for Up to One Additional Element}

The ressult from the above bootstrapping procedures are summarised in Table \ref{tab:allPlusOneBoot}, and these values are directly comparable with those in Table \ref{tab:allSingleBoot}.

<<allPlusOneBoot, echo=FALSE, include=TRUE, results='asis'>>=
vapply(bootAluPlusOne, function(x){x$p}, numeric(1)) %>%
  as.data.frame() %>%
  add_rownames("Tissue") %>%
  select(Tissue, alu = contains(".")) %>%
  mutate(Tissue = capwords(Tissue),
         L1 = vapply(bootL1PlusOne, function(x){x$p}, numeric(1)),
         L2 = vapply(bootL2PlusOne, function(x){x$p}, numeric(1)),
         LTR = vapply(bootLTRPlusOne, function(x){x$p}, numeric(1)),
         mir = vapply(bootMirPlusOne, function(x){x$p}, numeric(1))) %>%
  xtable(digits = 4,
         caption = "Bootstrapped p-values for Elements acting in the presence of up to one additional element",
         align = "llrrrrr",
         label = "tab:allPlusOneBoot") %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@


\FloatBarrier

\section{Elements in the Presence of Up To Two Additional Elements}
The impacts on the addition of one accompanying element were then investigated to increase the sample size \& gain a clearer picture of the wider genome.\\

\subsection{Alu Elements In the presence of Up To Two Additional Elements}
<<aluPlusTwoData>>=
aluPlusTwoData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("alu", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_", elBins))
countsAluPlusTwo <- count(aluPlusTwoData, alu, elBins) %>% 
  dcast(elBins~alu, value.var = "n") 
@

<<xtabAluPlusTwoData, echo=FALSE, include=TRUE, results='asis'>>=
countsAluPlusTwo %>% 
  rename(`Additional Element` = elBins,
         `Genes without an alu` = `FALSE`, 
         `Genes with an alu` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for alu elements, allowing up to one extra element.",
         label = "tab:aluPlusTwo",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootAluPlusTwo, cache=TRUE>>=
bootAluPlusTwo <- mclapply(tissues, bootMeans, 
                           data = aluPlusTwoData, 
                           testIds = filter(aluPlusTwoData, alu)$ID, 
                           refIds = filter(aluPlusTwoData, !alu)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootAluPlusTwo) <- tissues
@

<<plotAluPlusTwo, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with Alu elements in isolation when compared to genes with no TEs.">>=
vapply(bootAluPlusTwo, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:aluPlusTwo}, and the results of the bootstrapping procedure (Figure \ref{fig:plotAluPlusTwo}) are highly consistent with those from alu elements acting in isolation (Figure \ref{fig:plotBootAluOnly}).

\subsection{L1 Elements In the presence of Up To Two Additional Elements}
<<L1PlusTwoData, message=FALSE>>=
L1PlusTwoData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("L1", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_", elBins))
countsL1PlusTwo <- count(L1PlusTwoData, L1, elBins) %>% 
  dcast(elBins~L1, value.var = "n") 
@

<<xtabL1PlusTwoData, echo=FALSE, include=TRUE, results='asis'>>=
countsL1PlusTwo %>% 
  rename(`Additional Element` = elBins,
         `Genes without an L1` = `FALSE`, 
         `Genes with an L1` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for L1 elements, allowing up to one extra element.",
         label = "tab:L1PlusTwo",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootL1PlusTwo, cache=TRUE>>=
bootL1PlusTwo <- mclapply(tissues, bootMeans, 
                           data = L1PlusTwoData, 
                           testIds = filter(L1PlusTwoData, L1)$ID, 
                           refIds = filter(L1PlusTwoData, !L1)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootL1PlusTwo) <- tissues
@

<<plotL1PlusTwo, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L1 elements in isolation when compared to genes with no TEs.">>=
vapply(bootL1PlusTwo, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:L1PlusTwo}, and the results of the bootstrapping procedure (Figure \ref{fig:plotL1PlusTwo}) are highly consistent with those from L1 elements acting in isolation (Figure \ref{fig:plotBootL1Only}).

\subsection{L2 Elements In the presence of Up To Two Additional Elements}
<<L2PlusTwoData, message=FALSE>>=
L2PlusTwoData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("L2", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_", elBins))
countsL2PlusTwo <- count(L2PlusTwoData, L2, elBins) %>% 
  dcast(elBins~L2, value.var = "n") 
@

<<xtabL2PlusTwoData, echo=FALSE, include=TRUE, results='asis'>>=
countsL2PlusTwo %>% 
  rename(`Additional Element` = elBins,
         `Genes without an L2` = `FALSE`, 
         `Genes with an L2` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for L2 elements, allowing up to one extra element.",
         label = "tab:L2PlusTwo",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootL2PlusTwo, cache=TRUE>>=
bootL2PlusTwo <- mclapply(tissues, bootMeans, 
                           data = L2PlusTwoData, 
                           testIds = filter(L2PlusTwoData, L2)$ID, 
                           refIds = filter(L2PlusTwoData, !L2)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootL2PlusTwo) <- tissues
@

<<plotL2PlusTwo, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L2 elements in isolation when compared to genes with no TEs.">>=
vapply(bootL2PlusTwo, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:L2PlusTwo}, and the results of the bootstrapping procedure (Figure \ref{fig:plotL2PlusTwo}) are highly consistent with those from L2 elements acting in isolation (Figure \ref{fig:plotBootL2Only}).

\subsection{LTR Elements In the presence of Up To Two Additional Elements}
<<LTRPlusTwoData, message=FALSE>>=
LTRPlusTwoData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("LTR", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_", elBins))
countsLTRPlusTwo <- count(LTRPlusTwoData, LTR, elBins) %>% 
  dcast(elBins~LTR, value.var = "n") 
@

<<xtabLTRPlusTwoData, echo=FALSE, include=TRUE, results='asis'>>=
countsLTRPlusTwo %>% 
  rename(`Additional Element` = elBins,
         `Genes without an LTR` = `FALSE`, 
         `Genes with an LTR` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for LTR elements, allowing up to one extra element.",
         label = "tab:LTRPlusTwo",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootLTRPlusTwo, cache=TRUE>>=
bootLTRPlusTwo <- mclapply(tissues, bootMeans, 
                           data = LTRPlusTwoData, 
                           testIds = filter(LTRPlusTwoData, LTR)$ID, 
                           refIds = filter(LTRPlusTwoData, !LTR)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootLTRPlusTwo) <- tissues
@

<<plotLTRPlusTwo, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with LTR elements in isolation when compared to genes with no TEs.">>=
vapply(bootLTRPlusTwo, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:LTRPlusTwo}, and the results of the bootstrapping procedure (Figure \ref{fig:plotLTRPlusTwo}) are highly consistent with those from LTR elements acting in isolation (Figure \ref{fig:plotBootLTROnly}).

\subsection{mir Elements In the presence of Up To Two Additional Elements}
<<mirPlusTwoData, message=FALSE>>=
mirPlusTwoData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("mir", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_", elBins))
countsMirPlusTwo <- count(mirPlusTwoData, mir, elBins) %>% 
  dcast(elBins~mir, value.var = "n") 
@

<<xtabMirPlusTwoData, echo=FALSE, include=TRUE, results='asis'>>=
countsMirPlusTwo %>% 
  rename(`Additional Element` = elBins,
         `Genes without a mir` = `FALSE`, 
         `Genes with a mir` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for mir elements, allowing up to one extra element.",
         label = "tab:mirPlusTwo",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootMirPlusTwo, cache=TRUE>>=
bootMirPlusTwo <- mclapply(tissues, bootMeans, 
                           data = mirPlusTwoData, 
                           testIds = filter(mirPlusTwoData, mir)$ID, 
                           refIds = filter(mirPlusTwoData, !mir)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L)
names(bootMirPlusTwo) <- tissues
@

<<plotMirPlusTwo, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with mir elements in isolation when compared to genes with no TEs.">>=
vapply(bootMirPlusTwo, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:mirPlusTwo}, and the results of the bootstrapping procedure (Figure \ref{fig:plotMirPlusTwo}) are highly consistent with those from mir elements acting in isolation (Figure \ref{fig:plotBootMirOnly}).

\subsection{Summary of Results for Up To Two Additional Elements}

The ressult from the above bootstrapping procedures are summarised in Table \ref{tab:allPlusTwoBoot}, and these values are directly comparable with those in Table \ref{tab:allSingleBoot}.

<<allPlusTwoBoot, echo=FALSE, include=TRUE, results='asis'>>=
vapply(bootAluPlusTwo, function(x){x$p}, numeric(1)) %>%
  as.data.frame() %>%
  add_rownames("Tissue") %>%
  select(Tissue, alu = contains(".")) %>%
  mutate(Tissue = capwords(Tissue),
         L1 = vapply(bootL1PlusTwo, function(x){x$p}, numeric(1)),
         L2 = vapply(bootL2PlusTwo, function(x){x$p}, numeric(1)),
         LTR = vapply(bootLTRPlusTwo, function(x){x$p}, numeric(1)),
         mir = vapply(bootMirPlusTwo, function(x){x$p}, numeric(1))) %>%
  xtable(digits = 4,
         caption = "Bootstrapped p-values for Elements acting in the presence of up To Two Additional Elements",
         align = "llrrrrr",
         label = "tab:allPlusTwoBoot") %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@


\FloatBarrier

\section{Elements in the Presence of Up To Three Additional Elements}
The impacts on the addition of one accompanying element were then investigated to increase the sample size \& gain a clearer picture of the wider genome.\\

\subsection{Alu Elements In the presence of Up To Three Additional Elements}
<<aluPlusThreeData>>=
aluPlusThreeData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("alu", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_.+_", elBins))
countsAluPlusThree <- count(aluPlusThreeData, alu, elBins) %>% 
  dcast(elBins~alu, value.var = "n") 
@

<<xtabAluPlusThreeData, echo=FALSE, include=TRUE, results='asis'>>=
countsAluPlusThree %>% 
  rename(`Additional Element` = elBins,
         `Genes without an alu` = `FALSE`, 
         `Genes with an alu` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for alu elements, allowing up to one extra element.",
         label = "tab:aluPlusThree",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootAluPlusThree, cache=TRUE>>=
bootAluPlusThree <- mclapply(tissues, bootMeans, 
                           data = aluPlusThreeData, 
                           testIds = filter(aluPlusThreeData, alu)$ID, 
                           refIds = filter(aluPlusThreeData, !alu)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootAluPlusThree) <- tissues
@

<<plotAluPlusThree, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with Alu elements in combination with other elements compared to genes with up to three TEs.">>=
vapply(bootAluPlusThree, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:aluPlusThree}, and the results of the bootstrapping procedure (Figure \ref{fig:plotAluPlusThree}) are highly consistent with those from alu elements acting in isolation (Figure \ref{fig:plotBootAluOnly}).

\subsection{L1 Elements In the presence of Up To Three Additional Elements}
<<L1PlusThreeData, message=FALSE>>=
L1PlusThreeData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("L1", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_.+_", elBins))
countsL1PlusThree <- count(L1PlusThreeData, L1, elBins) %>% 
  dcast(elBins~L1, value.var = "n") 
@

<<xtabL1PlusThreeData, echo=FALSE, include=TRUE, results='asis'>>=
countsL1PlusThree %>% 
  rename(`Additional Element` = elBins,
         `Genes without an L1` = `FALSE`, 
         `Genes with an L1` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for L1 elements, allowing up to one extra element.",
         label = "tab:L1PlusThree",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootL1PlusThree, cache=TRUE>>=
bootL1PlusThree <- mclapply(tissues, bootMeans, 
                           data = L1PlusThreeData, 
                           testIds = filter(L1PlusThreeData, L1)$ID, 
                           refIds = filter(L1PlusThreeData, !L1)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootL1PlusThree) <- tissues
@

<<plotL1PlusThree, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L1 elements in combination with other elements compared to genes with up to three TEs.">>=
vapply(bootL1PlusThree, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:L1PlusThree}, and the results of the bootstrapping procedure (Figure \ref{fig:plotL1PlusThree}) are highly consistent with those from L1 elements acting in isolation (Figure \ref{fig:plotBootL1Only}).

\subsection{L2 Elements In the presence of Up To Three Additional Elements}
<<L2PlusThreeData, message=FALSE>>=
L2PlusThreeData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("L2", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_.+_", elBins))
countsL2PlusThree <- count(L2PlusThreeData, L2, elBins) %>% 
  dcast(elBins~L2, value.var = "n") 
@

<<xtabL2PlusThreeData, echo=FALSE, include=TRUE, results='asis'>>=
countsL2PlusThree %>% 
  rename(`Additional Element` = elBins,
         `Genes without an L2` = `FALSE`, 
         `Genes with an L2` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for L2 elements, allowing up to one extra element.",
         label = "tab:L2PlusThree",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootL2PlusThree, cache=TRUE>>=
bootL2PlusThree <- mclapply(tissues, bootMeans, 
                           data = L2PlusThreeData, 
                           testIds = filter(L2PlusThreeData, L2)$ID, 
                           refIds = filter(L2PlusThreeData, !L2)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootL2PlusThree) <- tissues
@

<<plotL2PlusThree, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with L2 elements in combination with other elements compared to genes with up to three TEs.">>=
vapply(bootL2PlusThree, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:L2PlusThree}, and the results of the bootstrapping procedure (Figure \ref{fig:plotL2PlusThree}) are highly consistent with those from L2 elements acting in isolation (Figure \ref{fig:plotBootL2Only}).

\subsection{LTR Elements In the presence of Up To Three Additional Elements}
<<LTRPlusThreeData, message=FALSE>>=
LTRPlusThreeData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("LTR", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_.+_", elBins))
countsLTRPlusThree <- count(LTRPlusThreeData, LTR, elBins) %>% 
  dcast(elBins~LTR, value.var = "n") 
@

<<xtabLTRPlusThreeData, echo=FALSE, include=TRUE, results='asis'>>=
countsLTRPlusThree %>% 
  rename(`Additional Element` = elBins,
         `Genes without an LTR` = `FALSE`, 
         `Genes with an LTR` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for LTR elements, allowing up to one extra element.",
         label = "tab:LTRPlusThree",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootLTRPlusThree, cache=TRUE>>=
bootLTRPlusThree <- mclapply(tissues, bootMeans, 
                           data = LTRPlusThreeData, 
                           testIds = filter(LTRPlusThreeData, LTR)$ID, 
                           refIds = filter(LTRPlusThreeData, !LTR)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootLTRPlusThree) <- tissues
@

<<plotLTRPlusThree, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with LTR elements in combination with other elements compared to genes with up to three TEs.">>=
vapply(bootLTRPlusThree, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:LTRPlusThree}, and the results of the bootstrapping procedure (Figure \ref{fig:plotLTRPlusThree}) are highly consistent with those from LTR elements acting in isolation (Figure \ref{fig:plotBootLTROnly}).

\subsection{mir Elements In the presence of Up To Three Additional Elements}
<<mirPlusThreeData, message=FALSE>>=
mirPlusThreeData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("mir", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  select(-contains("IDs")) %>%
  filter(!grepl("_.+_.+_", elBins))
countsMirPlusThree <- count(mirPlusThreeData, mir, elBins) %>% 
  dcast(elBins~mir, value.var = "n") 
@

<<xtabMirPlusThreeData, echo=FALSE, include=TRUE, results='asis'>>=
countsMirPlusThree %>% 
  rename(`Additional Element` = elBins,
         `Genes without a mir` = `FALSE`, 
         `Genes with a mir` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for mir elements, allowing up to one extra element.",
         label = "tab:mirPlusThree",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootMirPlusThree, cache=TRUE>>=
bootMirPlusThree <- mclapply(tissues, bootMeans, 
                           data = mirPlusThreeData, 
                           testIds = filter(mirPlusThreeData, mir)$ID, 
                           refIds = filter(mirPlusThreeData, !mir)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootMirPlusThree) <- tissues
@

<<plotMirPlusThree, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with mir elements in combination with other elements compared to genes with up to three TEs.">>=
vapply(bootMirPlusThree, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

The increase sample size as a result of this change is clearly seen in Table \ref{tab:mirPlusThree}, and the results of the bootstrapping procedure (Figure \ref{fig:plotMirPlusThree}) are highly consistent with those from mir elements acting in isolation (Figure \ref{fig:plotBootMirOnly}).

\subsection{Summary of Results for Up to Three Additional Elements}

The ressult from the above bootstrapping procedures are summarised in Table \ref{tab:allPlusThreeBoot}, and these values are directly comparable with those in Table \ref{tab:allSingleBoot}.

<<allPlusThreeBoot, echo=FALSE, include=TRUE, results='asis'>>=
vapply(bootAluPlusThree, function(x){x$p}, numeric(1)) %>%
  as.data.frame() %>%
  add_rownames("Tissue") %>%
  select(Tissue, alu = contains(".")) %>%
  mutate(Tissue = capwords(Tissue),
         L1 = vapply(bootL1PlusThree, function(x){x$p}, numeric(1)),
         L2 = vapply(bootL2PlusThree, function(x){x$p}, numeric(1)),
         LTR = vapply(bootLTRPlusThree, function(x){x$p}, numeric(1)),
         mir = vapply(bootMirPlusThree, function(x){x$p}, numeric(1))) %>%
  xtable(digits = 4,
         caption = "Bootstrapped p-values for Elements acting in the presence of up to Three Additional Elements",
         align = "llrrrrr",
         label = "tab:allPlusThreeBoot") %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@


\FloatBarrier

\section{Looking at each region for each element}

For this section, we can break each element down by region and compare genes with a specific element in a specific region, against genes with the same element, but in different regions.
For example, we cold compare genes with an alu in the Proximal Promoter against genes with an alu in one of the other three regions.

\subsection{alu elements}

Firstly the dataset was subset into the set of genes with an alu, temporarily ignoring genes with no alu element.
For this bootstrapping process, the number of iterations was initially set to 10000.

<<aluData>>=
nBoot = 10000L
aluData <- tpmData %>% 
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("alu", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  filter(alu)
@

\subsubsection*{alu Elements in the CDS Vs alu Elements in other regions}

<<aluBootCds, cache=TRUE>>=
aluBootCds <- mclapply(tissues, bootMeans,
                     data = aluData, 
                     testIds = filter(aluData, alu_cds_IDs == 1)$ID,
                     refIds = filter(aluData, alu_cds_IDs == 0)$ID,
                     binCol = "^elBins$",
                     nGenes = 1000, nBoot = nBoot, minGenes = 100)
names(aluBootCds) <- tissues
@

In comparison to genes with alu elements in other regions, it was noted that genes with an alu in the CDS were less likely to be detected as expressed (Table \ref{tab:aluCdsFisher}).

<<xTabAluBootCds, echo=FALSE, include=TRUE, results='asis'>>=
 aluBootCds %>% 
  lapply(function(x){data.frame(fisher.test(x$sampleSizes[,2:3])[c("estimate", "p.value")])}) %>% 
  bind_rows %>% 
  mutate(Tissue = capwords(tissues)) %>% 
  select(Tissue, OddsRatio = estimate, P = p.value) %>% 
  mutate(adjP = p.adjust(P, "bonferroni"), 
         Sig = aster(adjP)) %>%
  xtable(caption = "Tissue specific reults from Fisher Tests, indicating that genes with an alu in the CDS are less likely to be detected as expressed, in comparison to genes with an alu in another region.",
         label = "tab:aluCdsFisher",
         digits = c(0, 0, 3, -2, -2, 0)) %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

As seen in Figure \ref{fig:plotAluBootCds}, genes with an alu in the CDS exhibited clearly lower levels of expression when compared to genes with an alu in another region.
However, it should be noted that this number of genes was \Sexpr{sum(aluBootCds$adipose$sampleSizes[1,-1])} in total, and moany of these were declared as not expressed in the various tissues.


<<plotAluBootCds, fig.height=4, fig.cap="Bootstrapped Differences in mean log(TPM) for genes with an alu in the CDS, compared to genes with an alu in another region">>=
vapply(aluBootCds, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

\subsubsection*{alu Elements in the Proximal Promoter Vs alu Elements in other regions}

<<aluBootProx, cache=TRUE>>=
aluBootProx <- mclapply(tissues, bootMeans,
                     data = aluData, 
                     testIds = filter(aluData, alu_prox_IDs == 1)$ID,
                     refIds = filter(aluData, alu_prox_IDs == 0)$ID,
                     binCol = "^elBins$",
                     nGenes = 1000, nBoot = nBoot, minGenes = 100)
names(aluBootProx) <- tissues
@

In comparison to genes with alu elements in other regions, it was noted that genes with an alu in the CDS were less likely to be detected as expressed (Table \ref{tab:aluProxFisher}).

<<xTabAluBootProx, echo=FALSE, include=TRUE, results='asis'>>=
 aluBootProx %>% 
  lapply(function(x){data.frame(fisher.test(x$sampleSizes[,2:3])[c("estimate", "p.value")])}) %>% 
  bind_rows %>% 
  mutate(Tissue = capwords(tissues)) %>% 
  select(Tissue, OddsRatio = estimate, P = p.value) %>% 
  mutate(adjP = p.adjust(P, "bonferroni"), 
         Sig = aster(adjP)) %>%
  xtable(caption = "Tissue specific reults from Fisher Tests, indicating that genes with an alu in the Proximal Promoter are more likely to be detected as expressed, in comparison to genes with an alu in another region.",
         label = "tab:aluProxFisher",
         digits = c(0, 0, 3, -2, -2, 0)) %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

As seen in Figure \ref{fig:plotAluBootProx}, genes with an alu in the proximal promoter were clearly more highly expressed than genes with an alu in another region.
This sample represented \Sexpr{sum(aluBootProx$adipose$sampleSizes[1,-1])} genes, and was compared against a reference sample of \Sexpr{sum(aluBootProx$adipose$sampleSizes[2,-1])} genes.


<<plotAluBootProx, fig.height=4, fig.cap="Bootstrapped Differences in mean log(TPM) for genes with an alu in the Proximal Promoter, compared to genes with an alu in another region">>=
vapply(aluBootProx, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@



\subsubsection*{alu Elements in the 3'UTR Vs alu Elements in other regions}

<<aluBootUtr3, cache=TRUE>>=
aluBootUtr3 <- mclapply(tissues, bootMeans,
                     data = aluData, 
                     testIds = filter(aluData, alu_utr3_IDs == 1)$ID,
                     refIds = filter(aluData, alu_utr3_IDs == 0)$ID,
                     binCol = "^elBins$",
                     nGenes = 1000, nBoot = nBoot, minGenes = 100)
names(aluBootUtr3) <- tissues
@

In comparison to genes with alu elements in other regions, it was noted that genes with an alu in the 3'UTR were more likely to be detected as expressed (Table \ref{tab:aluUtr3Fisher}).

<<xTabAluBootUtr3, echo=FALSE, include=TRUE, results='asis'>>=
aluBootUtr3 %>% 
  lapply(function(x){data.frame(fisher.test(x$sampleSizes[,2:3])[c("estimate", "p.value")])}) %>% 
  bind_rows %>% 
  mutate(Tissue = capwords(tissues)) %>% 
  select(Tissue, OddsRatio = estimate, P = p.value) %>% 
  mutate(adjP = p.adjust(P, "bonferroni"), 
         Sig = aster(adjP)) %>%
  xtable(caption = "Tissue specific reults from Fisher Tests, indicating that genes with an alu in the 3'UTR are more likely to be detected as expressed, in comparison to genes with an alu in another region.",
         label = "tab:aluUtr3Fisher",
         digits = c(0, 0, 3, -2, -2, 0)) %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

As seen in Figure \ref{fig:plotAluBootUtr3}, genes with an alu in the 3'UTR were not as highly expressed as genes with an alu in another region, for most tissues.
However, this was not significantly different in Brain.
This sample represented \Sexpr{sum(aluBootUtr3$adipose$sampleSizes[1,-1])} genes, and was compared against a reference sample of \Sexpr{sum(aluBootUtr3$adipose$sampleSizes[2,-1])} genes.


<<plotAluBootUtr3, fig.height=4, fig.cap="Bootstrapped Differences in mean log(TPM) for genes with an alu in the 3'UTR, compared to genes with an alu in another region">>=
vapply(aluBootUtr3, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@


\subsubsection*{alu Elements in the 5'UTR Vs alu Elements in other regions}

Due to the over-representation of genes with every element in the 5'UTR, genes with the complete set of elements identified in the 5'UTR were ignored for this subsection of the analysis.


<<aluBootUtr5, cache=TRUE>>=
aluBootUtr5 <- mclapply(tissues, bootMeans,
                     data = filter(aluData, !grepl("_.+_.+_", elBins)), 
                     testIds = filter(aluData, alu_utr5_IDs == 1, 
                                      !grepl("_.+_.+_", elBins))$ID,
                     refIds = filter(aluData, alu_utr5_IDs == 0, 
                                     !grepl("_.+_.+_", elBins))$ID,
                     binCol = "^elBins$",
                     nGenes = 1000, nBoot = nBoot, 
                     minGenes = 100, maxP = 0.01)
names(aluBootUtr5) <- tissues
@

In comparison to genes with alu elements in other regions, it was noted that genes with an alu in the 5'UTR were less likely to be detected as expressed (Table \ref{tab:aluUtr5Fisher}).

<<xTabAluBootUtr5, echo=FALSE, include=TRUE, results='asis'>>=
aluBootUtr5 %>% 
  lapply(function(x){data.frame(fisher.test(x$sampleSizes[,2:3])[c("estimate", "p.value")])}) %>% 
  bind_rows %>% 
  mutate(Tissue = capwords(tissues)) %>% 
  select(Tissue, OddsRatio = estimate, P = p.value) %>% 
  mutate(adjP = p.adjust(P, "bonferroni"), 
         Sig = aster(adjP)) %>%
  xtable(caption = "Tissue specific reults from Fisher Tests, indicating that genes with an alu in the 5'UTR are less likely to be detected as expressed, in comparison to genes with an alu in another region.",
         label = "tab:aluUtr5Fisher",
         digits = c(0, 0, 3, -2, -2, 0)) %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

As seen in Figure \ref{fig:plotAluBootUtr5}, genes with an alu in the 5'UTR were not as highly expressed as genes with an alu in another region, for most tissues, with the exception of Skeletal Muscle and Testes.
This sample represented \Sexpr{sum(aluBootUtr5$adipose$sampleSizes[1,-1])} genes, and was compared against a reference sample of \Sexpr{sum(aluBootUtr5$adipose$sampleSizes[2,-1])} genes.


<<plotAluBootUtr5, fig.height=4, fig.cap="Bootstrapped Differences in mean log(TPM) for genes with an alu in the 5'UTR, compared to genes with an alu in another region">>=
vapply(aluBootUtr5, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

\subsection{Summary of Results for alu elements across the Regions}
It ws clear that alu elements in the both the CDS and 5'UTR decreased the probability of being detected as being expressed, in comparison to genes with an alu element in the Proximal Promoter or the 3'UTR.\\

In contrast to this, it appears that the majority of the upregulation observed as a result of a genes conatining an alu element, is due to the presence of an alu element in the proximal promoter


<<allRegsAlu, echo=FALSE, include=TRUE, results='asis'>>=
vapply(aluBootCds, function(x){x$p}, numeric(1)) %>%
  as.data.frame() %>%
  add_rownames("Tissue") %>%
  select(Tissue, CDS = contains(".")) %>%
  mutate(Tissue = capwords(Tissue),
         `Proximal Promoter` = vapply(aluBootProx, function(x){x$p}, numeric(1)),
         UTR3 = vapply(aluBootUtr3, function(x){x$p}, numeric(1)),
         UTR5 = vapply(aluBootUtr5, function(x){x$p}, numeric(1))) %>%
  xtable(digits = 4,
         caption = "Bootstrapped p-values for alu elements in each region, compared to alu elements in all other regions.",
         align = "llrrrr",
         label = "tab:allRegsAlu") %>%
  print(include.rownames = FALSE,
        caption.placement = "top")
@

\subsection{Comparison Against the Wider Set of Genes}

\subsubsection{Genes with an alu element in the proximal promoter only}
As the set of genes with an alu element in the proximal promoter appear to be the main source of any observed up-regulation, these genes were compared against the wider set of genes, which don't contain any alu element.

<<aluProxData>>=
aluProxData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("alu", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  filter(!grepl("_.+_.+_", elBins),
         alu_cds_IDs == 0, 
         alu_utr3_IDs == 0, alu_utr5_IDs == 0)
countsAluProxData <- count(aluProxData, alu, elBins) %>% 
  dcast(elBins~alu, value.var = "n") 
@

<<xtabAluProxData, echo=FALSE, include=TRUE, results='asis'>>=
countsAluProxData %>% 
  rename(`Additional Element` = elBins,
         `Genes without an alu` = `FALSE`, 
         `Genes with an alu` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for alu elements in the proximal promoter, allowing up to one extra element.",
         label = "tab:aluProxData",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootAluProx, cache=TRUE>>=
bootAluProx <- mclapply(tissues, bootMeans, 
                           data = aluProxData, 
                           testIds = filter(aluProxData, alu)$ID, 
                           refIds = filter(aluProxData, !alu)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootAluProx) <- tissues
@

<<plotAluProx, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with Alu elements in the proximal promoter.">>=
vapply(bootAluProx, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@

\subsubsection*{Genes with an alu element NOT in the proximal promoter}

<<aluNoProxData>>=
aluNoProxData <- tpmData %>%
  mutate(elBins = binsFromCols(select(tpmData, 
                                      one_of(grep("alu", 
                                                  elements$type, 
                                                  invert = TRUE, 
                                                  value = TRUE))))) %>%
  filter(!grepl("_.+_.+_", elBins), alu_prox_IDs == 0)
countsAluNoProxData <- count(aluNoProxData, alu, elBins) %>% 
  dcast(elBins~alu, value.var = "n") 
@

<<xtabAluNoProxData, echo=FALSE, include=TRUE, results='asis'>>=
countsAluNoProxData %>% 
  rename(`Additional Element` = elBins,
         `Genes without an alu` = `FALSE`, 
         `Genes with an alu` = `TRUE`) %>%
  xtable(caption = "Sample Sizes for alu elements not inthe proximal promoter, allowing up to one extra element.",
         label = "tab:aluProxData",
         digits = 0) %>%
  print(caption.placement = "top",
        include.rownames = FALSE)
@

<<bootAluNoProx, cache=TRUE>>=
bootAluNoProx <- mclapply(tissues, bootMeans, 
                           data = aluNoProxData, 
                           testIds = filter(aluNoProxData, alu)$ID, 
                           refIds = filter(aluNoProxData, !alu)$ID,
                           binCol = "elBins",
                           nBoot = nBoot, 
                           nGenes = 1000L,
                           maxP = 0.01)
names(bootAluNoProx) <- tissues
@

<<plotAluNoProx, echo=FALSE, fig.height= 4, fig.cap = "Bootstrapped differences in mean log(TPM) for genes with Alu elements not in the proximal promoter.">>=
vapply(bootAluNoProx, function(x){x$samples}, numeric(nBoot)) %>%
  melt(varnames = c("Row", "Tissue"), value.name = "TPM") %>%
  mutate(Tissue = gsub("_TPM", "", Tissue),
         Tissue = capwords(Tissue)) %>%
  ggplot(aes(x = TPM, fill = Tissue)) +
  geom_density(alpha = 0.5) +
  geom_vline(x = 0) +
  facet_wrap(~Tissue) +
  guides(fill = FALSE) +
  theme_bw()
@


\FloatBarrier
\appendix
\section{Session Info}

<<save, eval = FALSE, echo=FALSE>>=
save.image("TEBootstrapAnalysis.RData")
@


<<sessionInfo, results='markup'>>=
sessionInfo()
@


\end{document}